{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\n\nvar _CSSESC_QUOTE_OPTIONS;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nexports.unescapeValue = unescapeValue;\n\nvar _cssesc = require(\"cssesc\");\n\nvar _cssesc2 = _interopRequireDefault(_cssesc);\n\nvar _unesc = require(\"../util/unesc\");\n\nvar _unesc2 = _interopRequireDefault(_unesc);\n\nvar _namespace = require(\"./namespace\");\n\nvar _namespace2 = _interopRequireDefault(_namespace);\n\nvar _types = require(\"./types\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar _require = require(\"util\"),\n    deprecate = _require.deprecate;\n\nvar WRAPPED_IN_QUOTES = /^('|\")(.*)\\1$/;\nvar warnOfDeprecatedValueAssignment = deprecate(function () {}, \"Assigning an attribute a value containing characters that might need to be escaped is deprecated. \" + \"Call attribute.setValue() instead.\");\nvar warnOfDeprecatedQuotedAssignment = deprecate(function () {}, \"Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.\");\nvar warnOfDeprecatedConstructor = deprecate(function () {}, \"Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.\");\n\nfunction unescapeValue(value) {\n  var deprecatedUsage = false;\n  var quoteMark = null;\n  var unescaped = value;\n  var m = unescaped.match(WRAPPED_IN_QUOTES);\n\n  if (m) {\n    quoteMark = m[1];\n    unescaped = m[2];\n  }\n\n  unescaped = (0, _unesc2.default)(unescaped);\n\n  if (unescaped !== value) {\n    deprecatedUsage = true;\n  }\n\n  return {\n    deprecatedUsage: deprecatedUsage,\n    unescaped: unescaped,\n    quoteMark: quoteMark\n  };\n}\n\nfunction handleDeprecatedContructorOpts(opts) {\n  if (opts.quoteMark !== undefined) {\n    return opts;\n  }\n\n  if (opts.value === undefined) {\n    return opts;\n  }\n\n  warnOfDeprecatedConstructor();\n\n  var _unescapeValue = unescapeValue(opts.value),\n      quoteMark = _unescapeValue.quoteMark,\n      unescaped = _unescapeValue.unescaped;\n\n  if (!opts.raws) {\n    opts.raws = {};\n  }\n\n  if (opts.raws.value === undefined) {\n    opts.raws.value = opts.value;\n  }\n\n  opts.value = unescaped;\n  opts.quoteMark = quoteMark;\n  return opts;\n}\n\nvar Attribute = function (_Namespace) {\n  _inherits(Attribute, _Namespace);\n\n  function Attribute() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Attribute);\n\n    var _this = _possibleConstructorReturn(this, _Namespace.call(this, handleDeprecatedContructorOpts(opts)));\n\n    _this.type = _types.ATTRIBUTE;\n    _this.raws = _this.raws || {};\n    Object.defineProperty(_this.raws, 'unquoted', {\n      get: deprecate(function () {\n        return _this.value;\n      }, \"attr.raws.unquoted is deprecated. Call attr.value instead.\"),\n      set: deprecate(function () {\n        return _this.value;\n      }, \"Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.\")\n    });\n    _this._constructed = true;\n    return _this;\n  }\n  /**\n   * Returns the Attribute's value quoted such that it would be legal to use\n   * in the value of a css file. The original value's quotation setting\n   * used for stringification is left unchanged. See `setValue(value, options)`\n   * if you want to control the quote settings of a new value for the attribute.\n   *\n   * You can also change the quotation used for the current value by setting quoteMark.\n   *\n   * Options:\n   *   * quoteMark {'\"' | \"'\" | null} - Use this value to quote the value. If this\n   *     option is not set, the original value for quoteMark will be used. If\n   *     indeterminate, a double quote is used. The legal values are:\n   *     * `null` - the value will be unquoted and characters will be escaped as necessary.\n   *     * `'` - the value will be quoted with a single quote and single quotes are escaped.\n   *     * `\"` - the value will be quoted with a double quote and double quotes are escaped.\n   *   * preferCurrentQuoteMark {boolean} - if true, prefer the source quote mark\n   *     over the quoteMark option value.\n   *   * smart {boolean} - if true, will select a quote mark based on the value\n   *     and the other options specified here. See the `smartQuoteMark()`\n   *     method.\n   **/\n\n\n  Attribute.prototype.getQuotedValue = function getQuotedValue() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var quoteMark = this._determineQuoteMark(options);\n\n    var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];\n    var escaped = (0, _cssesc2.default)(this._value, cssescopts);\n    return escaped;\n  };\n\n  Attribute.prototype._determineQuoteMark = function _determineQuoteMark(options) {\n    return options.smart ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);\n  };\n  /**\n   * Set the unescaped value with the specified quotation options. The value\n   * provided must not include any wrapping quote marks -- those quotes will\n   * be interpreted as part of the value and escaped accordingly.\n   */\n\n\n  Attribute.prototype.setValue = function setValue(value) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this._value = value;\n    this._quoteMark = this._determineQuoteMark(options);\n\n    this._syncRawValue();\n  };\n  /**\n   * Intelligently select a quoteMark value based on the value's contents. If\n   * the value is a legal CSS ident, it will not be quoted. Otherwise a quote\n   * mark will be picked that minimizes the number of escapes.\n   *\n   * If there's no clear winner, the quote mark from these options is used,\n   * then the source quote mark (this is inverted if `preferCurrentQuoteMark` is\n   * true). If the quoteMark is unspecified, a double quote is used.\n   *\n   * @param options This takes the quoteMark and preferCurrentQuoteMark options\n   * from the quoteValue method.\n   */\n\n\n  Attribute.prototype.smartQuoteMark = function smartQuoteMark(options) {\n    var v = this.value;\n    var numSingleQuotes = v.replace(/[^']/g, '').length;\n    var numDoubleQuotes = v.replace(/[^\"]/g, '').length;\n\n    if (numSingleQuotes + numDoubleQuotes === 0) {\n      var escaped = (0, _cssesc2.default)(v, {\n        isIdentifier: true\n      });\n\n      if (escaped === v) {\n        return Attribute.NO_QUOTE;\n      } else {\n        var pref = this.preferredQuoteMark(options);\n\n        if (pref === Attribute.NO_QUOTE) {\n          // pick a quote mark that isn't none and see if it's smaller\n          var quote = this.quoteMark || options.quoteMark || Attribute.DOUBLE_QUOTE;\n          var opts = CSSESC_QUOTE_OPTIONS[quote];\n          var quoteValue = (0, _cssesc2.default)(v, opts);\n\n          if (quoteValue.length < escaped.length) {\n            return quote;\n          }\n        }\n\n        return pref;\n      }\n    } else if (numDoubleQuotes === numSingleQuotes) {\n      return this.preferredQuoteMark(options);\n    } else if (numDoubleQuotes < numSingleQuotes) {\n      return Attribute.DOUBLE_QUOTE;\n    } else {\n      return Attribute.SINGLE_QUOTE;\n    }\n  };\n  /**\n   * Selects the preferred quote mark based on the options and the current quote mark value.\n   * If you want the quote mark to depend on the attribute value, call `smartQuoteMark(opts)`\n   * instead.\n   */\n\n\n  Attribute.prototype.preferredQuoteMark = function preferredQuoteMark(options) {\n    var quoteMark = options.preferCurrentQuoteMark ? this.quoteMark : options.quoteMark;\n\n    if (quoteMark === undefined) {\n      quoteMark = options.preferCurrentQuoteMark ? options.quoteMark : this.quoteMark;\n    }\n\n    if (quoteMark === undefined) {\n      quoteMark = Attribute.DOUBLE_QUOTE;\n    }\n\n    return quoteMark;\n  };\n\n  Attribute.prototype._syncRawValue = function _syncRawValue() {\n    var rawValue = (0, _cssesc2.default)(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);\n\n    if (rawValue === this._value) {\n      if (this.raws) {\n        delete this.raws.value;\n      }\n    } else {\n      this.raws.value = rawValue;\n    }\n  };\n\n  Attribute.prototype._handleEscapes = function _handleEscapes(prop, value) {\n    if (this._constructed) {\n      var escaped = (0, _cssesc2.default)(value, {\n        isIdentifier: true\n      });\n\n      if (escaped !== value) {\n        this.raws[prop] = escaped;\n      } else {\n        delete this.raws[prop];\n      }\n    }\n  };\n\n  Attribute.prototype._spacesFor = function _spacesFor(name) {\n    var attrSpaces = {\n      before: '',\n      after: ''\n    };\n    var spaces = this.spaces[name] || {};\n    var rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};\n    return Object.assign(attrSpaces, spaces, rawSpaces);\n  };\n\n  Attribute.prototype._stringFor = function _stringFor(name) {\n    var spaceName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : name;\n    var concat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultAttrConcat;\n\n    var attrSpaces = this._spacesFor(spaceName);\n\n    return concat(this.stringifyProperty(name), attrSpaces);\n  };\n  /**\n   * returns the offset of the attribute part specified relative to the\n   * start of the node of the output string.\n   *\n   * * \"ns\" - alias for \"namespace\"\n   * * \"namespace\" - the namespace if it exists.\n   * * \"attribute\" - the attribute name\n   * * \"attributeNS\" - the start of the attribute or its namespace\n   * * \"operator\" - the match operator of the attribute\n   * * \"value\" - The value (string or identifier)\n   * * \"insensitive\" - the case insensitivity flag;\n   * @param part One of the possible values inside an attribute.\n   * @returns -1 if the name is invalid or the value doesn't exist in this attribute.\n   */\n\n\n  Attribute.prototype.offsetOf = function offsetOf(name) {\n    var count = 1;\n\n    var attributeSpaces = this._spacesFor(\"attribute\");\n\n    count += attributeSpaces.before.length;\n\n    if (name === \"namespace\" || name === \"ns\") {\n      return this.namespace ? count : -1;\n    }\n\n    if (name === \"attributeNS\") {\n      return count;\n    }\n\n    count += this.namespaceString.length;\n\n    if (this.namespace) {\n      count += 1;\n    }\n\n    if (name === \"attribute\") {\n      return count;\n    }\n\n    count += this.stringifyProperty(\"attribute\").length;\n    count += attributeSpaces.after.length;\n\n    var operatorSpaces = this._spacesFor(\"operator\");\n\n    count += operatorSpaces.before.length;\n    var operator = this.stringifyProperty(\"operator\");\n\n    if (name === \"operator\") {\n      return operator ? count : -1;\n    }\n\n    count += operator.length;\n    count += operatorSpaces.after.length;\n\n    var valueSpaces = this._spacesFor(\"value\");\n\n    count += valueSpaces.before.length;\n    var value = this.stringifyProperty(\"value\");\n\n    if (name === \"value\") {\n      return value ? count : -1;\n    }\n\n    count += value.length;\n    count += valueSpaces.after.length;\n\n    var insensitiveSpaces = this._spacesFor(\"insensitive\");\n\n    count += insensitiveSpaces.before.length;\n\n    if (name === \"insensitive\") {\n      return this.insensitive ? count : -1;\n    }\n\n    return -1;\n  };\n\n  Attribute.prototype.toString = function toString() {\n    var _this2 = this;\n\n    var selector = [this.rawSpaceBefore, '['];\n    selector.push(this._stringFor('qualifiedAttribute', 'attribute'));\n\n    if (this.operator && this.value) {\n      selector.push(this._stringFor('operator'));\n      selector.push(this._stringFor('value'));\n      selector.push(this._stringFor('insensitiveFlag', 'insensitive', function (attrValue, attrSpaces) {\n        if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {\n          attrSpaces.before = \" \";\n        }\n\n        return defaultAttrConcat(attrValue, attrSpaces);\n      }));\n    }\n\n    selector.push(']');\n    selector.push(this.rawSpaceAfter);\n    return selector.join('');\n  };\n\n  _createClass(Attribute, [{\n    key: \"quoted\",\n    get: function get() {\n      var qm = this.quoteMark;\n      return qm === \"'\" || qm === '\"';\n    },\n    set: function set(value) {\n      warnOfDeprecatedQuotedAssignment();\n    }\n    /**\n     * returns a single (`'`) or double (`\"`) quote character if the value is quoted.\n     * returns `null` if the value is not quoted.\n     * returns `undefined` if the quotation state is unknown (this can happen when\n     * the attribute is constructed without specifying a quote mark.)\n     */\n\n  }, {\n    key: \"quoteMark\",\n    get: function get() {\n      return this._quoteMark;\n    }\n    /**\n     * Set the quote mark to be used by this attribute's value.\n     * If the quote mark changes, the raw (escaped) value at `attr.raws.value` of the attribute\n     * value is updated accordingly.\n     *\n     * @param {\"'\" | '\"' | null} quoteMark The quote mark or `null` if the value should be unquoted.\n     */\n    ,\n    set: function set(quoteMark) {\n      if (!this._constructed) {\n        this._quoteMark = quoteMark;\n        return;\n      }\n\n      if (this._quoteMark !== quoteMark) {\n        this._quoteMark = quoteMark;\n\n        this._syncRawValue();\n      }\n    }\n  }, {\n    key: \"qualifiedAttribute\",\n    get: function get() {\n      return this.qualifiedName(this.raws.attribute || this.attribute);\n    }\n  }, {\n    key: \"insensitiveFlag\",\n    get: function get() {\n      return this.insensitive ? 'i' : '';\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this._value;\n    }\n    /**\n     * Before 3.0, the value had to be set to an escaped value including any wrapped\n     * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value\n     * is unescaped during parsing and any quote marks are removed.\n     *\n     * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,\n     * a deprecation warning is raised when the new value contains any characters that would\n     * require escaping (including if it contains wrapped quotes).\n     *\n     * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe\n     * how the new value is quoted.\n     */\n    ,\n    set: function set(v) {\n      if (this._constructed) {\n        var _unescapeValue2 = unescapeValue(v),\n            deprecatedUsage = _unescapeValue2.deprecatedUsage,\n            unescaped = _unescapeValue2.unescaped,\n            quoteMark = _unescapeValue2.quoteMark;\n\n        if (deprecatedUsage) {\n          warnOfDeprecatedValueAssignment();\n        }\n\n        if (unescaped === this._value && quoteMark === this._quoteMark) {\n          return;\n        }\n\n        this._value = unescaped;\n        this._quoteMark = quoteMark;\n\n        this._syncRawValue();\n      } else {\n        this._value = v;\n      }\n    }\n  }, {\n    key: \"attribute\",\n    get: function get() {\n      return this._attribute;\n    },\n    set: function set(name) {\n      this._handleEscapes(\"attribute\", name);\n\n      this._attribute = name;\n    }\n  }]);\n\n  return Attribute;\n}(_namespace2.default);\n\nAttribute.NO_QUOTE = null;\nAttribute.SINGLE_QUOTE = \"'\";\nAttribute.DOUBLE_QUOTE = '\"';\nexports.default = Attribute;\nvar CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {\n  \"'\": {\n    quotes: 'single',\n    wrap: true\n  },\n  '\"': {\n    quotes: 'double',\n    wrap: true\n  }\n}, _CSSESC_QUOTE_OPTIONS[null] = {\n  isIdentifier: true\n}, _CSSESC_QUOTE_OPTIONS);\n\nfunction defaultAttrConcat(attrValue, attrSpaces) {\n  return \"\" + attrSpaces.before + attrValue + attrSpaces.after;\n}","map":{"version":3,"sources":["/Users/santando/xlbas-project/node_modules/postcss-selector-parser/dist/selectors/attribute.js"],"names":["exports","__esModule","_CSSESC_QUOTE_OPTIONS","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","prototype","unescapeValue","_cssesc","require","_cssesc2","_interopRequireDefault","_unesc","_unesc2","_namespace","_namespace2","_types","obj","default","_classCallCheck","instance","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","create","constructor","value","setPrototypeOf","__proto__","_require","deprecate","WRAPPED_IN_QUOTES","warnOfDeprecatedValueAssignment","warnOfDeprecatedQuotedAssignment","warnOfDeprecatedConstructor","deprecatedUsage","quoteMark","unescaped","m","match","handleDeprecatedContructorOpts","opts","undefined","_unescapeValue","raws","Attribute","_Namespace","arguments","_this","type","ATTRIBUTE","get","set","_constructed","getQuotedValue","options","_determineQuoteMark","cssescopts","CSSESC_QUOTE_OPTIONS","escaped","_value","smart","smartQuoteMark","preferredQuoteMark","setValue","_quoteMark","_syncRawValue","v","numSingleQuotes","replace","numDoubleQuotes","isIdentifier","NO_QUOTE","pref","quote","DOUBLE_QUOTE","quoteValue","SINGLE_QUOTE","preferCurrentQuoteMark","rawValue","_handleEscapes","prop","_spacesFor","name","attrSpaces","before","after","spaces","rawSpaces","assign","_stringFor","spaceName","concat","defaultAttrConcat","stringifyProperty","offsetOf","count","attributeSpaces","namespace","namespaceString","operatorSpaces","operator","valueSpaces","insensitiveSpaces","insensitive","toString","_this2","selector","rawSpaceBefore","push","attrValue","quoted","rawSpaceAfter","join","qm","qualifiedName","attribute","_unescapeValue2","_attribute","quotes","wrap"],"mappings":"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","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\n\nvar _CSSESC_QUOTE_OPTIONS;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.unescapeValue = unescapeValue;\n\nvar _cssesc = require(\"cssesc\");\n\nvar _cssesc2 = _interopRequireDefault(_cssesc);\n\nvar _unesc = require(\"../util/unesc\");\n\nvar _unesc2 = _interopRequireDefault(_unesc);\n\nvar _namespace = require(\"./namespace\");\n\nvar _namespace2 = _interopRequireDefault(_namespace);\n\nvar _types = require(\"./types\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _require = require(\"util\"),\n    deprecate = _require.deprecate;\n\nvar WRAPPED_IN_QUOTES = /^('|\")(.*)\\1$/;\n\nvar warnOfDeprecatedValueAssignment = deprecate(function () {}, \"Assigning an attribute a value containing characters that might need to be escaped is deprecated. \" + \"Call attribute.setValue() instead.\");\n\nvar warnOfDeprecatedQuotedAssignment = deprecate(function () {}, \"Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.\");\n\nvar warnOfDeprecatedConstructor = deprecate(function () {}, \"Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.\");\n\nfunction unescapeValue(value) {\n    var deprecatedUsage = false;\n    var quoteMark = null;\n    var unescaped = value;\n    var m = unescaped.match(WRAPPED_IN_QUOTES);\n    if (m) {\n        quoteMark = m[1];\n        unescaped = m[2];\n    }\n    unescaped = (0, _unesc2.default)(unescaped);\n    if (unescaped !== value) {\n        deprecatedUsage = true;\n    }\n    return {\n        deprecatedUsage: deprecatedUsage,\n        unescaped: unescaped,\n        quoteMark: quoteMark\n    };\n}\n\nfunction handleDeprecatedContructorOpts(opts) {\n    if (opts.quoteMark !== undefined) {\n        return opts;\n    }\n    if (opts.value === undefined) {\n        return opts;\n    }\n    warnOfDeprecatedConstructor();\n\n    var _unescapeValue = unescapeValue(opts.value),\n        quoteMark = _unescapeValue.quoteMark,\n        unescaped = _unescapeValue.unescaped;\n\n    if (!opts.raws) {\n        opts.raws = {};\n    }\n    if (opts.raws.value === undefined) {\n        opts.raws.value = opts.value;\n    }\n    opts.value = unescaped;\n    opts.quoteMark = quoteMark;\n    return opts;\n}\n\nvar Attribute = function (_Namespace) {\n    _inherits(Attribute, _Namespace);\n\n    function Attribute() {\n        var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, Attribute);\n\n        var _this = _possibleConstructorReturn(this, _Namespace.call(this, handleDeprecatedContructorOpts(opts)));\n\n        _this.type = _types.ATTRIBUTE;\n        _this.raws = _this.raws || {};\n        Object.defineProperty(_this.raws, 'unquoted', {\n            get: deprecate(function () {\n                return _this.value;\n            }, \"attr.raws.unquoted is deprecated. Call attr.value instead.\"),\n            set: deprecate(function () {\n                return _this.value;\n            }, \"Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.\")\n        });\n        _this._constructed = true;\n        return _this;\n    }\n\n    /**\n     * Returns the Attribute's value quoted such that it would be legal to use\n     * in the value of a css file. The original value's quotation setting\n     * used for stringification is left unchanged. See `setValue(value, options)`\n     * if you want to control the quote settings of a new value for the attribute.\n     *\n     * You can also change the quotation used for the current value by setting quoteMark.\n     *\n     * Options:\n     *   * quoteMark {'\"' | \"'\" | null} - Use this value to quote the value. If this\n     *     option is not set, the original value for quoteMark will be used. If\n     *     indeterminate, a double quote is used. The legal values are:\n     *     * `null` - the value will be unquoted and characters will be escaped as necessary.\n     *     * `'` - the value will be quoted with a single quote and single quotes are escaped.\n     *     * `\"` - the value will be quoted with a double quote and double quotes are escaped.\n     *   * preferCurrentQuoteMark {boolean} - if true, prefer the source quote mark\n     *     over the quoteMark option value.\n     *   * smart {boolean} - if true, will select a quote mark based on the value\n     *     and the other options specified here. See the `smartQuoteMark()`\n     *     method.\n     **/\n\n\n    Attribute.prototype.getQuotedValue = function getQuotedValue() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        var quoteMark = this._determineQuoteMark(options);\n        var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];\n        var escaped = (0, _cssesc2.default)(this._value, cssescopts);\n        return escaped;\n    };\n\n    Attribute.prototype._determineQuoteMark = function _determineQuoteMark(options) {\n        return options.smart ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);\n    };\n\n    /**\n     * Set the unescaped value with the specified quotation options. The value\n     * provided must not include any wrapping quote marks -- those quotes will\n     * be interpreted as part of the value and escaped accordingly.\n     */\n\n\n    Attribute.prototype.setValue = function setValue(value) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        this._value = value;\n        this._quoteMark = this._determineQuoteMark(options);\n        this._syncRawValue();\n    };\n\n    /**\n     * Intelligently select a quoteMark value based on the value's contents. If\n     * the value is a legal CSS ident, it will not be quoted. Otherwise a quote\n     * mark will be picked that minimizes the number of escapes.\n     *\n     * If there's no clear winner, the quote mark from these options is used,\n     * then the source quote mark (this is inverted if `preferCurrentQuoteMark` is\n     * true). If the quoteMark is unspecified, a double quote is used.\n     *\n     * @param options This takes the quoteMark and preferCurrentQuoteMark options\n     * from the quoteValue method.\n     */\n\n\n    Attribute.prototype.smartQuoteMark = function smartQuoteMark(options) {\n        var v = this.value;\n        var numSingleQuotes = v.replace(/[^']/g, '').length;\n        var numDoubleQuotes = v.replace(/[^\"]/g, '').length;\n        if (numSingleQuotes + numDoubleQuotes === 0) {\n            var escaped = (0, _cssesc2.default)(v, { isIdentifier: true });\n            if (escaped === v) {\n                return Attribute.NO_QUOTE;\n            } else {\n                var pref = this.preferredQuoteMark(options);\n                if (pref === Attribute.NO_QUOTE) {\n                    // pick a quote mark that isn't none and see if it's smaller\n                    var quote = this.quoteMark || options.quoteMark || Attribute.DOUBLE_QUOTE;\n                    var opts = CSSESC_QUOTE_OPTIONS[quote];\n                    var quoteValue = (0, _cssesc2.default)(v, opts);\n                    if (quoteValue.length < escaped.length) {\n                        return quote;\n                    }\n                }\n                return pref;\n            }\n        } else if (numDoubleQuotes === numSingleQuotes) {\n            return this.preferredQuoteMark(options);\n        } else if (numDoubleQuotes < numSingleQuotes) {\n            return Attribute.DOUBLE_QUOTE;\n        } else {\n            return Attribute.SINGLE_QUOTE;\n        }\n    };\n\n    /**\n     * Selects the preferred quote mark based on the options and the current quote mark value.\n     * If you want the quote mark to depend on the attribute value, call `smartQuoteMark(opts)`\n     * instead.\n     */\n\n\n    Attribute.prototype.preferredQuoteMark = function preferredQuoteMark(options) {\n        var quoteMark = options.preferCurrentQuoteMark ? this.quoteMark : options.quoteMark;\n\n        if (quoteMark === undefined) {\n            quoteMark = options.preferCurrentQuoteMark ? options.quoteMark : this.quoteMark;\n        }\n\n        if (quoteMark === undefined) {\n            quoteMark = Attribute.DOUBLE_QUOTE;\n        }\n\n        return quoteMark;\n    };\n\n    Attribute.prototype._syncRawValue = function _syncRawValue() {\n        var rawValue = (0, _cssesc2.default)(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);\n        if (rawValue === this._value) {\n            if (this.raws) {\n                delete this.raws.value;\n            }\n        } else {\n            this.raws.value = rawValue;\n        }\n    };\n\n    Attribute.prototype._handleEscapes = function _handleEscapes(prop, value) {\n        if (this._constructed) {\n            var escaped = (0, _cssesc2.default)(value, { isIdentifier: true });\n            if (escaped !== value) {\n                this.raws[prop] = escaped;\n            } else {\n                delete this.raws[prop];\n            }\n        }\n    };\n\n    Attribute.prototype._spacesFor = function _spacesFor(name) {\n        var attrSpaces = { before: '', after: '' };\n        var spaces = this.spaces[name] || {};\n        var rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};\n        return Object.assign(attrSpaces, spaces, rawSpaces);\n    };\n\n    Attribute.prototype._stringFor = function _stringFor(name) {\n        var spaceName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : name;\n        var concat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultAttrConcat;\n\n        var attrSpaces = this._spacesFor(spaceName);\n        return concat(this.stringifyProperty(name), attrSpaces);\n    };\n\n    /**\n     * returns the offset of the attribute part specified relative to the\n     * start of the node of the output string.\n     *\n     * * \"ns\" - alias for \"namespace\"\n     * * \"namespace\" - the namespace if it exists.\n     * * \"attribute\" - the attribute name\n     * * \"attributeNS\" - the start of the attribute or its namespace\n     * * \"operator\" - the match operator of the attribute\n     * * \"value\" - The value (string or identifier)\n     * * \"insensitive\" - the case insensitivity flag;\n     * @param part One of the possible values inside an attribute.\n     * @returns -1 if the name is invalid or the value doesn't exist in this attribute.\n     */\n\n\n    Attribute.prototype.offsetOf = function offsetOf(name) {\n        var count = 1;\n        var attributeSpaces = this._spacesFor(\"attribute\");\n        count += attributeSpaces.before.length;\n        if (name === \"namespace\" || name === \"ns\") {\n            return this.namespace ? count : -1;\n        }\n        if (name === \"attributeNS\") {\n            return count;\n        }\n\n        count += this.namespaceString.length;\n        if (this.namespace) {\n            count += 1;\n        }\n        if (name === \"attribute\") {\n            return count;\n        }\n\n        count += this.stringifyProperty(\"attribute\").length;\n        count += attributeSpaces.after.length;\n        var operatorSpaces = this._spacesFor(\"operator\");\n        count += operatorSpaces.before.length;\n        var operator = this.stringifyProperty(\"operator\");\n        if (name === \"operator\") {\n            return operator ? count : -1;\n        }\n\n        count += operator.length;\n        count += operatorSpaces.after.length;\n        var valueSpaces = this._spacesFor(\"value\");\n        count += valueSpaces.before.length;\n        var value = this.stringifyProperty(\"value\");\n        if (name === \"value\") {\n            return value ? count : -1;\n        }\n\n        count += value.length;\n        count += valueSpaces.after.length;\n        var insensitiveSpaces = this._spacesFor(\"insensitive\");\n        count += insensitiveSpaces.before.length;\n        if (name === \"insensitive\") {\n            return this.insensitive ? count : -1;\n        }\n        return -1;\n    };\n\n    Attribute.prototype.toString = function toString() {\n        var _this2 = this;\n\n        var selector = [this.rawSpaceBefore, '['];\n\n        selector.push(this._stringFor('qualifiedAttribute', 'attribute'));\n\n        if (this.operator && this.value) {\n            selector.push(this._stringFor('operator'));\n            selector.push(this._stringFor('value'));\n            selector.push(this._stringFor('insensitiveFlag', 'insensitive', function (attrValue, attrSpaces) {\n                if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {\n                    attrSpaces.before = \" \";\n                }\n                return defaultAttrConcat(attrValue, attrSpaces);\n            }));\n        }\n\n        selector.push(']');\n        selector.push(this.rawSpaceAfter);\n        return selector.join('');\n    };\n\n    _createClass(Attribute, [{\n        key: \"quoted\",\n        get: function get() {\n            var qm = this.quoteMark;\n            return qm === \"'\" || qm === '\"';\n        },\n        set: function set(value) {\n            warnOfDeprecatedQuotedAssignment();\n        }\n\n        /**\n         * returns a single (`'`) or double (`\"`) quote character if the value is quoted.\n         * returns `null` if the value is not quoted.\n         * returns `undefined` if the quotation state is unknown (this can happen when\n         * the attribute is constructed without specifying a quote mark.)\n         */\n\n    }, {\n        key: \"quoteMark\",\n        get: function get() {\n            return this._quoteMark;\n        }\n\n        /**\n         * Set the quote mark to be used by this attribute's value.\n         * If the quote mark changes, the raw (escaped) value at `attr.raws.value` of the attribute\n         * value is updated accordingly.\n         *\n         * @param {\"'\" | '\"' | null} quoteMark The quote mark or `null` if the value should be unquoted.\n         */\n        ,\n        set: function set(quoteMark) {\n            if (!this._constructed) {\n                this._quoteMark = quoteMark;\n                return;\n            }\n            if (this._quoteMark !== quoteMark) {\n                this._quoteMark = quoteMark;\n                this._syncRawValue();\n            }\n        }\n    }, {\n        key: \"qualifiedAttribute\",\n        get: function get() {\n            return this.qualifiedName(this.raws.attribute || this.attribute);\n        }\n    }, {\n        key: \"insensitiveFlag\",\n        get: function get() {\n            return this.insensitive ? 'i' : '';\n        }\n    }, {\n        key: \"value\",\n        get: function get() {\n            return this._value;\n        }\n\n        /**\n         * Before 3.0, the value had to be set to an escaped value including any wrapped\n         * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value\n         * is unescaped during parsing and any quote marks are removed.\n         *\n         * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,\n         * a deprecation warning is raised when the new value contains any characters that would\n         * require escaping (including if it contains wrapped quotes).\n         *\n         * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe\n         * how the new value is quoted.\n         */\n        ,\n        set: function set(v) {\n            if (this._constructed) {\n                var _unescapeValue2 = unescapeValue(v),\n                    deprecatedUsage = _unescapeValue2.deprecatedUsage,\n                    unescaped = _unescapeValue2.unescaped,\n                    quoteMark = _unescapeValue2.quoteMark;\n\n                if (deprecatedUsage) {\n                    warnOfDeprecatedValueAssignment();\n                }\n                if (unescaped === this._value && quoteMark === this._quoteMark) {\n                    return;\n                }\n                this._value = unescaped;\n                this._quoteMark = quoteMark;\n                this._syncRawValue();\n            } else {\n                this._value = v;\n            }\n        }\n    }, {\n        key: \"attribute\",\n        get: function get() {\n            return this._attribute;\n        },\n        set: function set(name) {\n            this._handleEscapes(\"attribute\", name);\n            this._attribute = name;\n        }\n    }]);\n\n    return Attribute;\n}(_namespace2.default);\n\nAttribute.NO_QUOTE = null;\nAttribute.SINGLE_QUOTE = \"'\";\nAttribute.DOUBLE_QUOTE = '\"';\nexports.default = Attribute;\n\n\nvar CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {\n    \"'\": { quotes: 'single', wrap: true },\n    '\"': { quotes: 'double', wrap: true }\n}, _CSSESC_QUOTE_OPTIONS[null] = { isIdentifier: true }, _CSSESC_QUOTE_OPTIONS);\n\nfunction defaultAttrConcat(attrValue, attrSpaces) {\n    return \"\" + attrSpaces.before + attrValue + attrSpaces.after;\n}"]},"metadata":{},"sourceType":"script"}