{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\n\nvar _parser = require(\"./parser\");\n\nvar _parser2 = _interopRequireDefault(_parser);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar Processor = function () {\n  function Processor(func, options) {\n    _classCallCheck(this, Processor);\n\n    this.func = func || function noop() {};\n\n    this.funcRes = null;\n    this.options = options;\n  }\n\n  Processor.prototype._shouldUpdateSelector = function _shouldUpdateSelector(rule) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var merged = Object.assign({}, this.options, options);\n\n    if (merged.updateSelector === false) {\n      return false;\n    } else {\n      return typeof rule !== \"string\";\n    }\n  };\n\n  Processor.prototype._isLossy = function _isLossy() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var merged = Object.assign({}, this.options, options);\n\n    if (merged.lossless === false) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  Processor.prototype._root = function _root(rule) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var parser = new _parser2.default(rule, this._parseOptions(options));\n    return parser.root;\n  };\n\n  Processor.prototype._parseOptions = function _parseOptions(options) {\n    return {\n      lossy: this._isLossy(options)\n    };\n  };\n\n  Processor.prototype._run = function _run(rule) {\n    var _this = this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return new Promise(function (resolve, reject) {\n      try {\n        var root = _this._root(rule, options);\n\n        Promise.resolve(_this.func(root)).then(function (transform) {\n          var string = undefined;\n\n          if (_this._shouldUpdateSelector(rule, options)) {\n            string = root.toString();\n            rule.selector = string;\n          }\n\n          return {\n            transform: transform,\n            root: root,\n            string: string\n          };\n        }).then(resolve, reject);\n      } catch (e) {\n        reject(e);\n        return;\n      }\n    });\n  };\n\n  Processor.prototype._runSync = function _runSync(rule) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var root = this._root(rule, options);\n\n    var transform = this.func(root);\n\n    if (transform && typeof transform.then === \"function\") {\n      throw new Error(\"Selector processor returned a promise to a synchronous call.\");\n    }\n\n    var string = undefined;\n\n    if (options.updateSelector && typeof rule !== \"string\") {\n      string = root.toString();\n      rule.selector = string;\n    }\n\n    return {\n      transform: transform,\n      root: root,\n      string: string\n    };\n  };\n  /**\n   * Process rule into a selector AST.\n   *\n   * @param rule {postcss.Rule | string} The css selector to be processed\n   * @param options The options for processing\n   * @returns {Promise<parser.Root>} The AST of the selector after processing it.\n   */\n\n\n  Processor.prototype.ast = function ast(rule, options) {\n    return this._run(rule, options).then(function (result) {\n      return result.root;\n    });\n  };\n  /**\n   * Process rule into a selector AST synchronously.\n   *\n   * @param rule {postcss.Rule | string} The css selector to be processed\n   * @param options The options for processing\n   * @returns {parser.Root} The AST of the selector after processing it.\n   */\n\n\n  Processor.prototype.astSync = function astSync(rule, options) {\n    return this._runSync(rule, options).root;\n  };\n  /**\n   * Process a selector into a transformed value asynchronously\n   *\n   * @param rule {postcss.Rule | string} The css selector to be processed\n   * @param options The options for processing\n   * @returns {Promise<any>} The value returned by the processor.\n   */\n\n\n  Processor.prototype.transform = function transform(rule, options) {\n    return this._run(rule, options).then(function (result) {\n      return result.transform;\n    });\n  };\n  /**\n   * Process a selector into a transformed value synchronously.\n   *\n   * @param rule {postcss.Rule | string} The css selector to be processed\n   * @param options The options for processing\n   * @returns {any} The value returned by the processor.\n   */\n\n\n  Processor.prototype.transformSync = function transformSync(rule, options) {\n    return this._runSync(rule, options).transform;\n  };\n  /**\n   * Process a selector into a new selector string asynchronously.\n   *\n   * @param rule {postcss.Rule | string} The css selector to be processed\n   * @param options The options for processing\n   * @returns {string} the selector after processing.\n   */\n\n\n  Processor.prototype.process = function process(rule, options) {\n    return this._run(rule, options).then(function (result) {\n      return result.string || result.root.toString();\n    });\n  };\n  /**\n   * Process a selector into a new selector string synchronously.\n   *\n   * @param rule {postcss.Rule | string} The css selector to be processed\n   * @param options The options for processing\n   * @returns {string} the selector after processing.\n   */\n\n\n  Processor.prototype.processSync = function processSync(rule, options) {\n    var result = this._runSync(rule, options);\n\n    return result.string || result.root.toString();\n  };\n\n  return Processor;\n}();\n\nexports.default = Processor;\nmodule.exports = exports[\"default\"];","map":{"version":3,"sources":["/Users/santando/xlbas-project/node_modules/postcss-selector-parser/dist/processor.js"],"names":["exports","__esModule","_parser","require","_parser2","_interopRequireDefault","obj","default","_classCallCheck","instance","Constructor","TypeError","Processor","func","options","noop","funcRes","prototype","_shouldUpdateSelector","rule","arguments","length","undefined","merged","Object","assign","updateSelector","_isLossy","lossless","_root","parser","_parseOptions","root","lossy","_run","_this","Promise","resolve","reject","then","transform","string","toString","selector","e","_runSync","Error","ast","result","astSync","transformSync","process","processSync","module"],"mappings":"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","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\n\nvar _parser = require(\"./parser\");\n\nvar _parser2 = _interopRequireDefault(_parser);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Processor = function () {\n    function Processor(func, options) {\n        _classCallCheck(this, Processor);\n\n        this.func = func || function noop() {};\n        this.funcRes = null;\n        this.options = options;\n    }\n\n    Processor.prototype._shouldUpdateSelector = function _shouldUpdateSelector(rule) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        var merged = Object.assign({}, this.options, options);\n        if (merged.updateSelector === false) {\n            return false;\n        } else {\n            return typeof rule !== \"string\";\n        }\n    };\n\n    Processor.prototype._isLossy = function _isLossy() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        var merged = Object.assign({}, this.options, options);\n        if (merged.lossless === false) {\n            return true;\n        } else {\n            return false;\n        }\n    };\n\n    Processor.prototype._root = function _root(rule) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        var parser = new _parser2.default(rule, this._parseOptions(options));\n        return parser.root;\n    };\n\n    Processor.prototype._parseOptions = function _parseOptions(options) {\n        return {\n            lossy: this._isLossy(options)\n        };\n    };\n\n    Processor.prototype._run = function _run(rule) {\n        var _this = this;\n\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        return new Promise(function (resolve, reject) {\n            try {\n                var root = _this._root(rule, options);\n                Promise.resolve(_this.func(root)).then(function (transform) {\n                    var string = undefined;\n                    if (_this._shouldUpdateSelector(rule, options)) {\n                        string = root.toString();\n                        rule.selector = string;\n                    }\n                    return { transform: transform, root: root, string: string };\n                }).then(resolve, reject);\n            } catch (e) {\n                reject(e);\n                return;\n            }\n        });\n    };\n\n    Processor.prototype._runSync = function _runSync(rule) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        var root = this._root(rule, options);\n        var transform = this.func(root);\n        if (transform && typeof transform.then === \"function\") {\n            throw new Error(\"Selector processor returned a promise to a synchronous call.\");\n        }\n        var string = undefined;\n        if (options.updateSelector && typeof rule !== \"string\") {\n            string = root.toString();\n            rule.selector = string;\n        }\n        return { transform: transform, root: root, string: string };\n    };\n\n    /**\n     * Process rule into a selector AST.\n     *\n     * @param rule {postcss.Rule | string} The css selector to be processed\n     * @param options The options for processing\n     * @returns {Promise<parser.Root>} The AST of the selector after processing it.\n     */\n\n\n    Processor.prototype.ast = function ast(rule, options) {\n        return this._run(rule, options).then(function (result) {\n            return result.root;\n        });\n    };\n\n    /**\n     * Process rule into a selector AST synchronously.\n     *\n     * @param rule {postcss.Rule | string} The css selector to be processed\n     * @param options The options for processing\n     * @returns {parser.Root} The AST of the selector after processing it.\n     */\n\n\n    Processor.prototype.astSync = function astSync(rule, options) {\n        return this._runSync(rule, options).root;\n    };\n\n    /**\n     * Process a selector into a transformed value asynchronously\n     *\n     * @param rule {postcss.Rule | string} The css selector to be processed\n     * @param options The options for processing\n     * @returns {Promise<any>} The value returned by the processor.\n     */\n\n\n    Processor.prototype.transform = function transform(rule, options) {\n        return this._run(rule, options).then(function (result) {\n            return result.transform;\n        });\n    };\n\n    /**\n     * Process a selector into a transformed value synchronously.\n     *\n     * @param rule {postcss.Rule | string} The css selector to be processed\n     * @param options The options for processing\n     * @returns {any} The value returned by the processor.\n     */\n\n\n    Processor.prototype.transformSync = function transformSync(rule, options) {\n        return this._runSync(rule, options).transform;\n    };\n\n    /**\n     * Process a selector into a new selector string asynchronously.\n     *\n     * @param rule {postcss.Rule | string} The css selector to be processed\n     * @param options The options for processing\n     * @returns {string} the selector after processing.\n     */\n\n\n    Processor.prototype.process = function process(rule, options) {\n        return this._run(rule, options).then(function (result) {\n            return result.string || result.root.toString();\n        });\n    };\n\n    /**\n     * Process a selector into a new selector string synchronously.\n     *\n     * @param rule {postcss.Rule | string} The css selector to be processed\n     * @param options The options for processing\n     * @returns {string} the selector after processing.\n     */\n\n\n    Processor.prototype.processSync = function processSync(rule, options) {\n        var result = this._runSync(rule, options);\n        return result.string || result.root.toString();\n    };\n\n    return Processor;\n}();\n\nexports.default = Processor;\nmodule.exports = exports[\"default\"];"]},"metadata":{},"sourceType":"script"}