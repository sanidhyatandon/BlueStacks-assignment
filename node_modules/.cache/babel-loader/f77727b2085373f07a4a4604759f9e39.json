{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.FIELDS = undefined;\n\nvar _unescapable, _wordDelimiters;\n\nexports.default = tokenize;\n\nvar _tokenTypes = require('./tokenTypes');\n\nvar t = _interopRequireWildcard(_tokenTypes);\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nvar unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);\nvar wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);\nvar hex = {};\nvar hexChars = \"0123456789abcdefABCDEF\";\n\nfor (var i = 0; i < hexChars.length; i++) {\n  hex[hexChars.charCodeAt(i)] = true;\n}\n/**\n *  Returns the last index of the bar css word\n * @param {string} css The string in which the word begins\n * @param {number} start The index into the string where word's first letter occurs\n */\n\n\nfunction consumeWord(css, start) {\n  var next = start;\n  var code = void 0;\n\n  do {\n    code = css.charCodeAt(next);\n\n    if (wordDelimiters[code]) {\n      return next - 1;\n    } else if (code === t.backslash) {\n      next = consumeEscape(css, next) + 1;\n    } else {\n      // All other characters are part of the word\n      next++;\n    }\n  } while (next < css.length);\n\n  return next - 1;\n}\n/**\n *  Returns the last index of the escape sequence\n * @param {string} css The string in which the sequence begins\n * @param {number} start The index into the string where escape character (`\\`) occurs.\n */\n\n\nfunction consumeEscape(css, start) {\n  var next = start;\n  var code = css.charCodeAt(next + 1);\n\n  if (unescapable[code]) {// just consume the escape char\n  } else if (hex[code]) {\n    var hexDigits = 0; // consume up to 6 hex chars\n\n    do {\n      next++;\n      hexDigits++;\n      code = css.charCodeAt(next + 1);\n    } while (hex[code] && hexDigits < 6); // if fewer than 6 hex chars, a trailing space ends the escape\n\n\n    if (hexDigits < 6 && code === t.space) {\n      next++;\n    }\n  } else {\n    // the next char is part of the current word\n    next++;\n  }\n\n  return next;\n}\n\nvar FIELDS = exports.FIELDS = {\n  TYPE: 0,\n  START_LINE: 1,\n  START_COL: 2,\n  END_LINE: 3,\n  END_COL: 4,\n  START_POS: 5,\n  END_POS: 6\n};\n\nfunction tokenize(input) {\n  var tokens = [];\n  var css = input.css.valueOf();\n  var _css = css,\n      length = _css.length;\n  var offset = -1;\n  var line = 1;\n  var start = 0;\n  var end = 0;\n  var code = void 0,\n      content = void 0,\n      endColumn = void 0,\n      endLine = void 0,\n      escaped = void 0,\n      escapePos = void 0,\n      last = void 0,\n      lines = void 0,\n      next = void 0,\n      nextLine = void 0,\n      nextOffset = void 0,\n      quote = void 0,\n      tokenType = void 0;\n\n  function unclosed(what, fix) {\n    if (input.safe) {\n      // fyi: this is never set to true.\n      css += fix;\n      next = css.length - 1;\n    } else {\n      throw input.error('Unclosed ' + what, line, start - offset, start);\n    }\n  }\n\n  while (start < length) {\n    code = css.charCodeAt(start);\n\n    if (code === t.newline) {\n      offset = start;\n      line += 1;\n    }\n\n    switch (code) {\n      case t.space:\n      case t.tab:\n      case t.newline:\n      case t.cr:\n      case t.feed:\n        next = start;\n\n        do {\n          next += 1;\n          code = css.charCodeAt(next);\n\n          if (code === t.newline) {\n            offset = next;\n            line += 1;\n          }\n        } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);\n\n        tokenType = t.space;\n        endLine = line;\n        endColumn = next - offset - 1;\n        end = next;\n        break;\n\n      case t.plus:\n      case t.greaterThan:\n      case t.tilde:\n      case t.pipe:\n        next = start;\n\n        do {\n          next += 1;\n          code = css.charCodeAt(next);\n        } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);\n\n        tokenType = t.combinator;\n        endLine = line;\n        endColumn = start - offset;\n        end = next;\n        break;\n      // Consume these characters as single tokens.\n\n      case t.asterisk:\n      case t.ampersand:\n      case t.bang:\n      case t.comma:\n      case t.equals:\n      case t.dollar:\n      case t.caret:\n      case t.openSquare:\n      case t.closeSquare:\n      case t.colon:\n      case t.semicolon:\n      case t.openParenthesis:\n      case t.closeParenthesis:\n        next = start;\n        tokenType = code;\n        endLine = line;\n        endColumn = start - offset;\n        end = next + 1;\n        break;\n\n      case t.singleQuote:\n      case t.doubleQuote:\n        quote = code === t.singleQuote ? \"'\" : '\"';\n        next = start;\n\n        do {\n          escaped = false;\n          next = css.indexOf(quote, next + 1);\n\n          if (next === -1) {\n            unclosed('quote', quote);\n          }\n\n          escapePos = next;\n\n          while (css.charCodeAt(escapePos - 1) === t.backslash) {\n            escapePos -= 1;\n            escaped = !escaped;\n          }\n        } while (escaped);\n\n        tokenType = t.str;\n        endLine = line;\n        endColumn = start - offset;\n        end = next + 1;\n        break;\n\n      default:\n        if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {\n          next = css.indexOf('*/', start + 2) + 1;\n\n          if (next === 0) {\n            unclosed('comment', '*/');\n          }\n\n          content = css.slice(start, next + 1);\n          lines = content.split('\\n');\n          last = lines.length - 1;\n\n          if (last > 0) {\n            nextLine = line + last;\n            nextOffset = next - lines[last].length;\n          } else {\n            nextLine = line;\n            nextOffset = offset;\n          }\n\n          tokenType = t.comment;\n          line = nextLine;\n          endLine = nextLine;\n          endColumn = next - nextOffset;\n        } else if (code === t.slash) {\n          next = start;\n          tokenType = code;\n          endLine = line;\n          endColumn = start - offset;\n          end = next + 1;\n        } else {\n          next = consumeWord(css, start);\n          tokenType = t.word;\n          endLine = line;\n          endColumn = next - offset;\n        }\n\n        end = next + 1;\n        break;\n    } // Ensure that the token structure remains consistent\n\n\n    tokens.push([tokenType, // [0] Token type\n    line, // [1] Starting line\n    start - offset, // [2] Starting column\n    endLine, // [3] Ending line\n    endColumn, // [4] Ending column\n    start, // [5] Start position / Source index\n    end] // [6] End position\n    ); // Reset offset for the next token\n\n    if (nextOffset) {\n      offset = nextOffset;\n      nextOffset = null;\n    }\n\n    start = end;\n  }\n\n  return tokens;\n}","map":{"version":3,"sources":["/Users/santando/xlbas-project/node_modules/postcss-selector-parser/dist/tokenize.js"],"names":["exports","__esModule","FIELDS","undefined","_unescapable","_wordDelimiters","default","tokenize","_tokenTypes","require","t","_interopRequireWildcard","obj","newObj","key","Object","prototype","hasOwnProperty","call","unescapable","tab","newline","cr","feed","wordDelimiters","space","ampersand","asterisk","bang","comma","colon","semicolon","openParenthesis","closeParenthesis","openSquare","closeSquare","singleQuote","doubleQuote","plus","pipe","tilde","greaterThan","equals","dollar","caret","slash","hex","hexChars","i","length","charCodeAt","consumeWord","css","start","next","code","backslash","consumeEscape","hexDigits","TYPE","START_LINE","START_COL","END_LINE","END_COL","START_POS","END_POS","input","tokens","valueOf","_css","offset","line","end","content","endColumn","endLine","escaped","escapePos","last","lines","nextLine","nextOffset","quote","tokenType","unclosed","what","fix","safe","error","combinator","indexOf","str","slice","split","comment","word","push"],"mappings":"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","sourcesContent":["'use strict';\n\nexports.__esModule = true;\nexports.FIELDS = undefined;\n\nvar _unescapable, _wordDelimiters;\n\nexports.default = tokenize;\n\nvar _tokenTypes = require('./tokenTypes');\n\nvar t = _interopRequireWildcard(_tokenTypes);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);\nvar wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);\n\nvar hex = {};\nvar hexChars = \"0123456789abcdefABCDEF\";\nfor (var i = 0; i < hexChars.length; i++) {\n    hex[hexChars.charCodeAt(i)] = true;\n}\n\n/**\n *  Returns the last index of the bar css word\n * @param {string} css The string in which the word begins\n * @param {number} start The index into the string where word's first letter occurs\n */\nfunction consumeWord(css, start) {\n    var next = start;\n    var code = void 0;\n    do {\n        code = css.charCodeAt(next);\n        if (wordDelimiters[code]) {\n            return next - 1;\n        } else if (code === t.backslash) {\n            next = consumeEscape(css, next) + 1;\n        } else {\n            // All other characters are part of the word\n            next++;\n        }\n    } while (next < css.length);\n    return next - 1;\n}\n\n/**\n *  Returns the last index of the escape sequence\n * @param {string} css The string in which the sequence begins\n * @param {number} start The index into the string where escape character (`\\`) occurs.\n */\nfunction consumeEscape(css, start) {\n    var next = start;\n    var code = css.charCodeAt(next + 1);\n    if (unescapable[code]) {\n        // just consume the escape char\n    } else if (hex[code]) {\n        var hexDigits = 0;\n        // consume up to 6 hex chars\n        do {\n            next++;\n            hexDigits++;\n            code = css.charCodeAt(next + 1);\n        } while (hex[code] && hexDigits < 6);\n        // if fewer than 6 hex chars, a trailing space ends the escape\n        if (hexDigits < 6 && code === t.space) {\n            next++;\n        }\n    } else {\n        // the next char is part of the current word\n        next++;\n    }\n    return next;\n}\n\nvar FIELDS = exports.FIELDS = {\n    TYPE: 0,\n    START_LINE: 1,\n    START_COL: 2,\n    END_LINE: 3,\n    END_COL: 4,\n    START_POS: 5,\n    END_POS: 6\n};\n\nfunction tokenize(input) {\n    var tokens = [];\n    var css = input.css.valueOf();\n    var _css = css,\n        length = _css.length;\n\n    var offset = -1;\n    var line = 1;\n    var start = 0;\n    var end = 0;\n\n    var code = void 0,\n        content = void 0,\n        endColumn = void 0,\n        endLine = void 0,\n        escaped = void 0,\n        escapePos = void 0,\n        last = void 0,\n        lines = void 0,\n        next = void 0,\n        nextLine = void 0,\n        nextOffset = void 0,\n        quote = void 0,\n        tokenType = void 0;\n\n    function unclosed(what, fix) {\n        if (input.safe) {\n            // fyi: this is never set to true.\n            css += fix;\n            next = css.length - 1;\n        } else {\n            throw input.error('Unclosed ' + what, line, start - offset, start);\n        }\n    }\n\n    while (start < length) {\n        code = css.charCodeAt(start);\n\n        if (code === t.newline) {\n            offset = start;\n            line += 1;\n        }\n\n        switch (code) {\n            case t.space:\n            case t.tab:\n            case t.newline:\n            case t.cr:\n            case t.feed:\n                next = start;\n                do {\n                    next += 1;\n                    code = css.charCodeAt(next);\n                    if (code === t.newline) {\n                        offset = next;\n                        line += 1;\n                    }\n                } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);\n\n                tokenType = t.space;\n                endLine = line;\n                endColumn = next - offset - 1;\n                end = next;\n                break;\n\n            case t.plus:\n            case t.greaterThan:\n            case t.tilde:\n            case t.pipe:\n                next = start;\n                do {\n                    next += 1;\n                    code = css.charCodeAt(next);\n                } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);\n\n                tokenType = t.combinator;\n                endLine = line;\n                endColumn = start - offset;\n                end = next;\n                break;\n\n            // Consume these characters as single tokens.\n            case t.asterisk:\n            case t.ampersand:\n            case t.bang:\n            case t.comma:\n            case t.equals:\n            case t.dollar:\n            case t.caret:\n            case t.openSquare:\n            case t.closeSquare:\n            case t.colon:\n            case t.semicolon:\n            case t.openParenthesis:\n            case t.closeParenthesis:\n                next = start;\n                tokenType = code;\n                endLine = line;\n                endColumn = start - offset;\n                end = next + 1;\n                break;\n\n            case t.singleQuote:\n            case t.doubleQuote:\n                quote = code === t.singleQuote ? \"'\" : '\"';\n                next = start;\n                do {\n                    escaped = false;\n                    next = css.indexOf(quote, next + 1);\n                    if (next === -1) {\n                        unclosed('quote', quote);\n                    }\n                    escapePos = next;\n                    while (css.charCodeAt(escapePos - 1) === t.backslash) {\n                        escapePos -= 1;\n                        escaped = !escaped;\n                    }\n                } while (escaped);\n\n                tokenType = t.str;\n                endLine = line;\n                endColumn = start - offset;\n                end = next + 1;\n                break;\n\n            default:\n                if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {\n                    next = css.indexOf('*/', start + 2) + 1;\n                    if (next === 0) {\n                        unclosed('comment', '*/');\n                    }\n\n                    content = css.slice(start, next + 1);\n                    lines = content.split('\\n');\n                    last = lines.length - 1;\n\n                    if (last > 0) {\n                        nextLine = line + last;\n                        nextOffset = next - lines[last].length;\n                    } else {\n                        nextLine = line;\n                        nextOffset = offset;\n                    }\n\n                    tokenType = t.comment;\n                    line = nextLine;\n                    endLine = nextLine;\n                    endColumn = next - nextOffset;\n                } else if (code === t.slash) {\n                    next = start;\n                    tokenType = code;\n                    endLine = line;\n                    endColumn = start - offset;\n                    end = next + 1;\n                } else {\n                    next = consumeWord(css, start);\n                    tokenType = t.word;\n                    endLine = line;\n                    endColumn = next - offset;\n                }\n\n                end = next + 1;\n                break;\n        }\n\n        // Ensure that the token structure remains consistent\n        tokens.push([tokenType, // [0] Token type\n        line, // [1] Starting line\n        start - offset, // [2] Starting column\n        endLine, // [3] Ending line\n        endColumn, // [4] Ending column\n        start, // [5] Start position / Source index\n        end] // [6] End position\n        );\n\n        // Reset offset for the next token\n        if (nextOffset) {\n            offset = nextOffset;\n            nextOffset = null;\n        }\n\n        start = end;\n    }\n\n    return tokens;\n}"]},"metadata":{},"sourceType":"script"}