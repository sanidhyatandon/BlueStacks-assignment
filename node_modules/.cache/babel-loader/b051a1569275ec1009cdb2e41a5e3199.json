{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _WHITESPACE_TOKENS, _extends2;\n\nvar _indexesOf = require('indexes-of');\n\nvar _indexesOf2 = _interopRequireDefault(_indexesOf);\n\nvar _uniq = require('uniq');\n\nvar _uniq2 = _interopRequireDefault(_uniq);\n\nvar _root = require('./selectors/root');\n\nvar _root2 = _interopRequireDefault(_root);\n\nvar _selector = require('./selectors/selector');\n\nvar _selector2 = _interopRequireDefault(_selector);\n\nvar _className = require('./selectors/className');\n\nvar _className2 = _interopRequireDefault(_className);\n\nvar _comment = require('./selectors/comment');\n\nvar _comment2 = _interopRequireDefault(_comment);\n\nvar _id = require('./selectors/id');\n\nvar _id2 = _interopRequireDefault(_id);\n\nvar _tag = require('./selectors/tag');\n\nvar _tag2 = _interopRequireDefault(_tag);\n\nvar _string = require('./selectors/string');\n\nvar _string2 = _interopRequireDefault(_string);\n\nvar _pseudo = require('./selectors/pseudo');\n\nvar _pseudo2 = _interopRequireDefault(_pseudo);\n\nvar _attribute = require('./selectors/attribute');\n\nvar _attribute2 = _interopRequireDefault(_attribute);\n\nvar _universal = require('./selectors/universal');\n\nvar _universal2 = _interopRequireDefault(_universal);\n\nvar _combinator = require('./selectors/combinator');\n\nvar _combinator2 = _interopRequireDefault(_combinator);\n\nvar _nesting = require('./selectors/nesting');\n\nvar _nesting2 = _interopRequireDefault(_nesting);\n\nvar _sortAscending = require('./sortAscending');\n\nvar _sortAscending2 = _interopRequireDefault(_sortAscending);\n\nvar _tokenize = require('./tokenize');\n\nvar _tokenize2 = _interopRequireDefault(_tokenize);\n\nvar _tokenTypes = require('./tokenTypes');\n\nvar tokens = _interopRequireWildcard(_tokenTypes);\n\nvar _types = require('./selectors/types');\n\nvar types = _interopRequireWildcard(_types);\n\nvar _util = require('./util');\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);\n\nvar WHITESPACE_EQUIV_TOKENS = _extends({}, WHITESPACE_TOKENS, (_extends2 = {}, _extends2[tokens.comment] = true, _extends2));\n\nfunction tokenStart(token) {\n  return {\n    line: token[_tokenize.FIELDS.START_LINE],\n    column: token[_tokenize.FIELDS.START_COL]\n  };\n}\n\nfunction tokenEnd(token) {\n  return {\n    line: token[_tokenize.FIELDS.END_LINE],\n    column: token[_tokenize.FIELDS.END_COL]\n  };\n}\n\nfunction getSource(startLine, startColumn, endLine, endColumn) {\n  return {\n    start: {\n      line: startLine,\n      column: startColumn\n    },\n    end: {\n      line: endLine,\n      column: endColumn\n    }\n  };\n}\n\nfunction getTokenSource(token) {\n  return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);\n}\n\nfunction getTokenSourceSpan(startToken, endToken) {\n  if (!startToken) {\n    return undefined;\n  }\n\n  return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);\n}\n\nfunction unescapeProp(node, prop) {\n  var value = node[prop];\n\n  if (typeof value !== \"string\") {\n    return;\n  }\n\n  if (value.indexOf(\"\\\\\") !== -1) {\n    (0, _util.ensureObject)(node, 'raws');\n    node[prop] = (0, _util.unesc)(value);\n\n    if (node.raws[prop] === undefined) {\n      node.raws[prop] = value;\n    }\n  }\n\n  return node;\n}\n\nvar Parser = function () {\n  function Parser(rule) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Parser);\n\n    this.rule = rule;\n    this.options = Object.assign({\n      lossy: false,\n      safe: false\n    }, options);\n    this.position = 0;\n    this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;\n    this.tokens = (0, _tokenize2.default)({\n      css: this.css,\n      error: this._errorGenerator(),\n      safe: this.options.safe\n    });\n    var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);\n    this.root = new _root2.default({\n      source: rootSource\n    });\n    this.root.errorGenerator = this._errorGenerator();\n    var selector = new _selector2.default({\n      source: {\n        start: {\n          line: 1,\n          column: 1\n        }\n      }\n    });\n    this.root.append(selector);\n    this.current = selector;\n    this.loop();\n  }\n\n  Parser.prototype._errorGenerator = function _errorGenerator() {\n    var _this = this;\n\n    return function (message, errorOptions) {\n      if (typeof _this.rule === 'string') {\n        return new Error(message);\n      }\n\n      return _this.rule.error(message, errorOptions);\n    };\n  };\n\n  Parser.prototype.attribute = function attribute() {\n    var attr = [];\n    var startingToken = this.currToken;\n    this.position++;\n\n    while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {\n      attr.push(this.currToken);\n      this.position++;\n    }\n\n    if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {\n      return this.expected('closing square bracket', this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n\n    var len = attr.length;\n    var node = {\n      source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),\n      sourceIndex: startingToken[_tokenize.FIELDS.START_POS]\n    };\n\n    if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {\n      return this.expected('attribute', attr[0][_tokenize.FIELDS.START_POS]);\n    }\n\n    var pos = 0;\n    var spaceBefore = '';\n    var commentBefore = '';\n    var lastAdded = null;\n    var spaceAfterMeaningfulToken = false;\n\n    while (pos < len) {\n      var token = attr[pos];\n      var content = this.content(token);\n      var next = attr[pos + 1];\n\n      switch (token[_tokenize.FIELDS.TYPE]) {\n        case tokens.space:\n          // if (\n          //     len === 1 ||\n          //     pos === 0 && this.content(next) === '|'\n          // ) {\n          //     return this.expected('attribute', token[TOKEN.START_POS], content);\n          // }\n          spaceAfterMeaningfulToken = true;\n\n          if (this.options.lossy) {\n            break;\n          }\n\n          if (lastAdded) {\n            (0, _util.ensureObject)(node, 'spaces', lastAdded);\n            var prevContent = node.spaces[lastAdded].after || '';\n            node.spaces[lastAdded].after = prevContent + content;\n            var existingComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || null;\n\n            if (existingComment) {\n              node.raws.spaces[lastAdded].after = existingComment + content;\n            }\n          } else {\n            spaceBefore = spaceBefore + content;\n            commentBefore = commentBefore + content;\n          }\n\n          break;\n\n        case tokens.asterisk:\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          } else if ((!node.namespace || lastAdded === \"namespace\" && !spaceAfterMeaningfulToken) && next) {\n            if (spaceBefore) {\n              (0, _util.ensureObject)(node, 'spaces', 'attribute');\n              node.spaces.attribute.before = spaceBefore;\n              spaceBefore = '';\n            }\n\n            if (commentBefore) {\n              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');\n              node.raws.spaces.attribute.before = spaceBefore;\n              commentBefore = '';\n            }\n\n            node.namespace = (node.namespace || \"\") + content;\n            var rawValue = (0, _util.getProp)(node, 'raws', 'namespace') || null;\n\n            if (rawValue) {\n              node.raws.namespace += content;\n            }\n\n            lastAdded = 'namespace';\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.dollar:\n          if (lastAdded === \"value\") {\n            var oldRawValue = (0, _util.getProp)(node, 'raws', 'value');\n            node.value += \"$\";\n\n            if (oldRawValue) {\n              node.raws.value = oldRawValue + \"$\";\n            }\n\n            break;\n          }\n\n        // Falls through\n\n        case tokens.caret:\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.combinator:\n          if (content === '~' && next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          }\n\n          if (content !== '|') {\n            spaceAfterMeaningfulToken = false;\n            break;\n          }\n\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          } else if (!node.namespace && !node.attribute) {\n            node.namespace = true;\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.word:\n          if (next && this.content(next) === '|' && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.\n          !node.operator && !node.namespace) {\n            node.namespace = content;\n            lastAdded = 'namespace';\n          } else if (!node.attribute || lastAdded === \"attribute\" && !spaceAfterMeaningfulToken) {\n            if (spaceBefore) {\n              (0, _util.ensureObject)(node, 'spaces', 'attribute');\n              node.spaces.attribute.before = spaceBefore;\n              spaceBefore = '';\n            }\n\n            if (commentBefore) {\n              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');\n              node.raws.spaces.attribute.before = commentBefore;\n              commentBefore = '';\n            }\n\n            node.attribute = (node.attribute || \"\") + content;\n\n            var _rawValue = (0, _util.getProp)(node, 'raws', 'attribute') || null;\n\n            if (_rawValue) {\n              node.raws.attribute += content;\n            }\n\n            lastAdded = 'attribute';\n          } else if (!node.value || lastAdded === \"value\" && !spaceAfterMeaningfulToken) {\n            var _unescaped = (0, _util.unesc)(content);\n\n            var _oldRawValue = (0, _util.getProp)(node, 'raws', 'value') || '';\n\n            var oldValue = node.value || '';\n            node.value = oldValue + _unescaped;\n            node.quoteMark = null;\n\n            if (_unescaped !== content || _oldRawValue) {\n              (0, _util.ensureObject)(node, 'raws');\n              node.raws.value = (_oldRawValue || oldValue) + content;\n            }\n\n            lastAdded = 'value';\n          } else {\n            var insensitive = content === 'i' || content === \"I\";\n\n            if (node.value && (node.quoteMark || spaceAfterMeaningfulToken)) {\n              node.insensitive = insensitive;\n\n              if (!insensitive || content === \"I\") {\n                (0, _util.ensureObject)(node, 'raws');\n                node.raws.insensitiveFlag = content;\n              }\n\n              lastAdded = 'insensitive';\n\n              if (spaceBefore) {\n                (0, _util.ensureObject)(node, 'spaces', 'insensitive');\n                node.spaces.insensitive.before = spaceBefore;\n                spaceBefore = '';\n              }\n\n              if (commentBefore) {\n                (0, _util.ensureObject)(node, 'raws', 'spaces', 'insensitive');\n                node.raws.spaces.insensitive.before = commentBefore;\n                commentBefore = '';\n              }\n            } else if (node.value) {\n              lastAdded = 'value';\n              node.value += content;\n\n              if (node.raws.value) {\n                node.raws.value += content;\n              }\n            }\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.str:\n          if (!node.attribute || !node.operator) {\n            return this.error('Expected an attribute followed by an operator preceding the string.', {\n              index: token[_tokenize.FIELDS.START_POS]\n            });\n          }\n\n          var _unescapeValue = (0, _attribute.unescapeValue)(content),\n              unescaped = _unescapeValue.unescaped,\n              quoteMark = _unescapeValue.quoteMark;\n\n          node.value = unescaped;\n          node.quoteMark = quoteMark;\n          lastAdded = 'value';\n          (0, _util.ensureObject)(node, 'raws');\n          node.raws.value = content;\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.equals:\n          if (!node.attribute) {\n            return this.expected('attribute', token[_tokenize.FIELDS.START_POS], content);\n          }\n\n          if (node.value) {\n            return this.error('Unexpected \"=\" found; an operator was already defined.', {\n              index: token[_tokenize.FIELDS.START_POS]\n            });\n          }\n\n          node.operator = node.operator ? node.operator + content : content;\n          lastAdded = 'operator';\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.comment:\n          if (lastAdded) {\n            if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === 'insensitive') {\n              var lastComment = (0, _util.getProp)(node, 'spaces', lastAdded, 'after') || '';\n              var rawLastComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || lastComment;\n              (0, _util.ensureObject)(node, 'raws', 'spaces', lastAdded);\n              node.raws.spaces[lastAdded].after = rawLastComment + content;\n            } else {\n              var lastValue = node[lastAdded] || '';\n              var rawLastValue = (0, _util.getProp)(node, 'raws', lastAdded) || lastValue;\n              (0, _util.ensureObject)(node, 'raws');\n              node.raws[lastAdded] = rawLastValue + content;\n            }\n          } else {\n            commentBefore = commentBefore + content;\n          }\n\n          break;\n\n        default:\n          return this.error('Unexpected \"' + content + '\" found.', {\n            index: token[_tokenize.FIELDS.START_POS]\n          });\n      }\n\n      pos++;\n    }\n\n    unescapeProp(node, \"attribute\");\n    unescapeProp(node, \"namespace\");\n    this.newNode(new _attribute2.default(node));\n    this.position++;\n  };\n  /**\n   * return a node containing meaningless garbage up to (but not including) the specified token position.\n   * if the token position is negative, all remaining tokens are consumed.\n   *\n   * This returns an array containing a single string node if all whitespace,\n   * otherwise an array of comment nodes with space before and after.\n   *\n   * These tokens are not added to the current selector, the caller can add them or use them to amend\n   * a previous node's space metadata.\n   *\n   * In lossy mode, this returns only comments.\n   */\n\n\n  Parser.prototype.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {\n    if (stopPosition < 0) {\n      stopPosition = this.tokens.length;\n    }\n\n    var startPosition = this.position;\n    var nodes = [];\n    var space = \"\";\n    var lastComment = undefined;\n\n    do {\n      if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {\n        if (!this.options.lossy) {\n          space += this.content();\n        }\n      } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {\n        var spaces = {};\n\n        if (space) {\n          spaces.before = space;\n          space = \"\";\n        }\n\n        lastComment = new _comment2.default({\n          value: this.content(),\n          source: getTokenSource(this.currToken),\n          sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],\n          spaces: spaces\n        });\n        nodes.push(lastComment);\n      }\n    } while (++this.position < stopPosition);\n\n    if (space) {\n      if (lastComment) {\n        lastComment.spaces.after = space;\n      } else if (!this.options.lossy) {\n        var firstToken = this.tokens[startPosition];\n        var lastToken = this.tokens[this.position - 1];\n        nodes.push(new _string2.default({\n          value: '',\n          source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),\n          sourceIndex: firstToken[_tokenize.FIELDS.START_POS],\n          spaces: {\n            before: space,\n            after: ''\n          }\n        }));\n      }\n    }\n\n    return nodes;\n  };\n  /**\n   * \n   * @param {*} nodes \n   */\n\n\n  Parser.prototype.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes) {\n    var _this2 = this;\n\n    var requiredSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var space = \"\";\n    var rawSpace = \"\";\n    nodes.forEach(function (n) {\n      var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);\n\n      var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);\n\n      space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);\n      rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);\n    });\n\n    if (rawSpace === space) {\n      rawSpace = undefined;\n    }\n\n    var result = {\n      space: space,\n      rawSpace: rawSpace\n    };\n    return result;\n  };\n\n  Parser.prototype.isNamedCombinator = function isNamedCombinator() {\n    var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.position;\n    return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;\n  };\n\n  Parser.prototype.namedCombinator = function namedCombinator() {\n    if (this.isNamedCombinator()) {\n      var nameRaw = this.content(this.tokens[this.position + 1]);\n      var name = (0, _util.unesc)(nameRaw).toLowerCase();\n      var raws = {};\n\n      if (name !== nameRaw) {\n        raws.value = '/' + nameRaw + '/';\n      }\n\n      var node = new _combinator2.default({\n        value: '/' + name + '/',\n        source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),\n        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],\n        raws: raws\n      });\n      this.position = this.position + 3;\n      return node;\n    } else {\n      this.unexpected();\n    }\n  };\n\n  Parser.prototype.combinator = function combinator() {\n    var _this3 = this;\n\n    if (this.content() === '|') {\n      return this.namespace();\n    } // We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.\n\n\n    var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);\n\n    if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {\n      var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n\n      if (nodes.length > 0) {\n        var last = this.current.last;\n\n        if (last) {\n          var _convertWhitespaceNod = this.convertWhitespaceNodesToSpace(nodes),\n              space = _convertWhitespaceNod.space,\n              rawSpace = _convertWhitespaceNod.rawSpace;\n\n          if (rawSpace !== undefined) {\n            last.rawSpaceAfter += rawSpace;\n          }\n\n          last.spaces.after += space;\n        } else {\n          nodes.forEach(function (n) {\n            return _this3.newNode(n);\n          });\n        }\n      }\n\n      return;\n    }\n\n    var firstToken = this.currToken;\n    var spaceOrDescendantSelectorNodes = undefined;\n\n    if (nextSigTokenPos > this.position) {\n      spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n    }\n\n    var node = void 0;\n\n    if (this.isNamedCombinator()) {\n      node = this.namedCombinator();\n    } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {\n      node = new _combinator2.default({\n        value: this.content(),\n        source: getTokenSource(this.currToken),\n        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]\n      });\n      this.position++;\n    } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {// pass\n    } else if (!spaceOrDescendantSelectorNodes) {\n      this.unexpected();\n    }\n\n    if (node) {\n      if (spaceOrDescendantSelectorNodes) {\n        var _convertWhitespaceNod2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes),\n            _space = _convertWhitespaceNod2.space,\n            _rawSpace = _convertWhitespaceNod2.rawSpace;\n\n        node.spaces.before = _space;\n        node.rawSpaceBefore = _rawSpace;\n      }\n    } else {\n      // descendant combinator\n      var _convertWhitespaceNod3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true),\n          _space2 = _convertWhitespaceNod3.space,\n          _rawSpace2 = _convertWhitespaceNod3.rawSpace;\n\n      if (!_rawSpace2) {\n        _rawSpace2 = _space2;\n      }\n\n      var spaces = {};\n      var raws = {\n        spaces: {}\n      };\n\n      if (_space2.endsWith(' ') && _rawSpace2.endsWith(' ')) {\n        spaces.before = _space2.slice(0, _space2.length - 1);\n        raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);\n      } else if (_space2.startsWith(' ') && _rawSpace2.startsWith(' ')) {\n        spaces.after = _space2.slice(1);\n        raws.spaces.after = _rawSpace2.slice(1);\n      } else {\n        raws.value = _rawSpace2;\n      }\n\n      node = new _combinator2.default({\n        value: ' ',\n        source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),\n        sourceIndex: firstToken[_tokenize.FIELDS.START_POS],\n        spaces: spaces,\n        raws: raws\n      });\n    }\n\n    if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {\n      node.spaces.after = this.optionalSpace(this.content());\n      this.position++;\n    }\n\n    return this.newNode(node);\n  };\n\n  Parser.prototype.comma = function comma() {\n    if (this.position === this.tokens.length - 1) {\n      this.root.trailingComma = true;\n      this.position++;\n      return;\n    }\n\n    this.current._inferEndPosition();\n\n    var selector = new _selector2.default({\n      source: {\n        start: tokenStart(this.tokens[this.position + 1])\n      }\n    });\n    this.current.parent.append(selector);\n    this.current = selector;\n    this.position++;\n  };\n\n  Parser.prototype.comment = function comment() {\n    var current = this.currToken;\n    this.newNode(new _comment2.default({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n\n  Parser.prototype.error = function error(message, opts) {\n    throw this.root.error(message, opts);\n  };\n\n  Parser.prototype.missingBackslash = function missingBackslash() {\n    return this.error('Expected a backslash preceding the semicolon.', {\n      index: this.currToken[_tokenize.FIELDS.START_POS]\n    });\n  };\n\n  Parser.prototype.missingParenthesis = function missingParenthesis() {\n    return this.expected('opening parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n\n  Parser.prototype.missingSquareBracket = function missingSquareBracket() {\n    return this.expected('opening square bracket', this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n\n  Parser.prototype.unexpected = function unexpected() {\n    return this.error('Unexpected \\'' + this.content() + '\\'. Escaping special characters with \\\\ may help.', this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n\n  Parser.prototype.namespace = function namespace() {\n    var before = this.prevToken && this.content(this.prevToken) || true;\n\n    if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {\n      this.position++;\n      return this.word(before);\n    } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {\n      this.position++;\n      return this.universal(before);\n    }\n  };\n\n  Parser.prototype.nesting = function nesting() {\n    if (this.nextToken) {\n      var nextContent = this.content(this.nextToken);\n\n      if (nextContent === \"|\") {\n        this.position++;\n        return;\n      }\n    }\n\n    var current = this.currToken;\n    this.newNode(new _nesting2.default({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n\n  Parser.prototype.parentheses = function parentheses() {\n    var last = this.current.last;\n    var unbalanced = 1;\n    this.position++;\n\n    if (last && last.type === types.PSEUDO) {\n      var selector = new _selector2.default({\n        source: {\n          start: tokenStart(this.tokens[this.position - 1])\n        }\n      });\n      var cache = this.current;\n      last.append(selector);\n      this.current = selector;\n\n      while (this.position < this.tokens.length && unbalanced) {\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          unbalanced++;\n        }\n\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n          unbalanced--;\n        }\n\n        if (unbalanced) {\n          this.parse();\n        } else {\n          this.current.source.end = tokenEnd(this.currToken);\n          this.current.parent.source.end = tokenEnd(this.currToken);\n          this.position++;\n        }\n      }\n\n      this.current = cache;\n    } else {\n      // I think this case should be an error. It's used to implement a basic parse of media queries\n      // but I don't think it's a good idea.\n      var parenStart = this.currToken;\n      var parenValue = \"(\";\n      var parenEnd = void 0;\n\n      while (this.position < this.tokens.length && unbalanced) {\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          unbalanced++;\n        }\n\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n          unbalanced--;\n        }\n\n        parenEnd = this.currToken;\n        parenValue += this.parseParenthesisToken(this.currToken);\n        this.position++;\n      }\n\n      if (last) {\n        last.appendToPropertyAndEscape(\"value\", parenValue, parenValue);\n      } else {\n        this.newNode(new _string2.default({\n          value: parenValue,\n          source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),\n          sourceIndex: parenStart[_tokenize.FIELDS.START_POS]\n        }));\n      }\n    }\n\n    if (unbalanced) {\n      return this.expected('closing parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n  };\n\n  Parser.prototype.pseudo = function pseudo() {\n    var _this4 = this;\n\n    var pseudoStr = '';\n    var startingToken = this.currToken;\n\n    while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {\n      pseudoStr += this.content();\n      this.position++;\n    }\n\n    if (!this.currToken) {\n      return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);\n    }\n\n    if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {\n      this.splitWord(false, function (first, length) {\n        pseudoStr += first;\n\n        _this4.newNode(new _pseudo2.default({\n          value: pseudoStr,\n          source: getTokenSourceSpan(startingToken, _this4.currToken),\n          sourceIndex: startingToken[_tokenize.FIELDS.START_POS]\n        }));\n\n        if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          _this4.error('Misplaced parenthesis.', {\n            index: _this4.nextToken[_tokenize.FIELDS.START_POS]\n          });\n        }\n      });\n    } else {\n      return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n  };\n\n  Parser.prototype.space = function space() {\n    var content = this.content(); // Handle space before and after the selector\n\n    if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n      this.spaces = this.optionalSpace(content);\n      this.position++;\n    } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n      this.current.last.spaces.after = this.optionalSpace(content);\n      this.position++;\n    } else {\n      this.combinator();\n    }\n  };\n\n  Parser.prototype.string = function string() {\n    var current = this.currToken;\n    this.newNode(new _string2.default({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n\n  Parser.prototype.universal = function universal(namespace) {\n    var nextToken = this.nextToken;\n\n    if (nextToken && this.content(nextToken) === '|') {\n      this.position++;\n      return this.namespace();\n    }\n\n    var current = this.currToken;\n    this.newNode(new _universal2.default({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }), namespace);\n    this.position++;\n  };\n\n  Parser.prototype.splitWord = function splitWord(namespace, firstCallback) {\n    var _this5 = this;\n\n    var nextToken = this.nextToken;\n    var word = this.content();\n\n    while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {\n      this.position++;\n      var current = this.content();\n      word += current;\n\n      if (current.lastIndexOf('\\\\') === current.length - 1) {\n        var next = this.nextToken;\n\n        if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {\n          word += this.requiredSpace(this.content(next));\n          this.position++;\n        }\n      }\n\n      nextToken = this.nextToken;\n    }\n\n    var hasClass = (0, _indexesOf2.default)(word, '.').filter(function (i) {\n      return word[i - 1] !== '\\\\';\n    });\n    var hasId = (0, _indexesOf2.default)(word, '#'); // Eliminate Sass interpolations from the list of id indexes\n\n    var interpolations = (0, _indexesOf2.default)(word, '#{');\n\n    if (interpolations.length) {\n      hasId = hasId.filter(function (hashIndex) {\n        return !~interpolations.indexOf(hashIndex);\n      });\n    }\n\n    var indices = (0, _sortAscending2.default)((0, _uniq2.default)([0].concat(hasClass, hasId)));\n    indices.forEach(function (ind, i) {\n      var index = indices[i + 1] || word.length;\n      var value = word.slice(ind, index);\n\n      if (i === 0 && firstCallback) {\n        return firstCallback.call(_this5, value, indices.length);\n      }\n\n      var node = void 0;\n      var current = _this5.currToken;\n      var sourceIndex = current[_tokenize.FIELDS.START_POS] + indices[i];\n      var source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));\n\n      if (~hasClass.indexOf(ind)) {\n        var classNameOpts = {\n          value: value.slice(1),\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        node = new _className2.default(unescapeProp(classNameOpts, \"value\"));\n      } else if (~hasId.indexOf(ind)) {\n        var idOpts = {\n          value: value.slice(1),\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        node = new _id2.default(unescapeProp(idOpts, \"value\"));\n      } else {\n        var tagOpts = {\n          value: value,\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        unescapeProp(tagOpts, \"value\");\n        node = new _tag2.default(tagOpts);\n      }\n\n      _this5.newNode(node, namespace); // Ensure that the namespace is used only once\n\n\n      namespace = null;\n    });\n    this.position++;\n  };\n\n  Parser.prototype.word = function word(namespace) {\n    var nextToken = this.nextToken;\n\n    if (nextToken && this.content(nextToken) === '|') {\n      this.position++;\n      return this.namespace();\n    }\n\n    return this.splitWord(namespace);\n  };\n\n  Parser.prototype.loop = function loop() {\n    while (this.position < this.tokens.length) {\n      this.parse(true);\n    }\n\n    this.current._inferEndPosition();\n\n    return this.root;\n  };\n\n  Parser.prototype.parse = function parse(throwOnParenthesis) {\n    switch (this.currToken[_tokenize.FIELDS.TYPE]) {\n      case tokens.space:\n        this.space();\n        break;\n\n      case tokens.comment:\n        this.comment();\n        break;\n\n      case tokens.openParenthesis:\n        this.parentheses();\n        break;\n\n      case tokens.closeParenthesis:\n        if (throwOnParenthesis) {\n          this.missingParenthesis();\n        }\n\n        break;\n\n      case tokens.openSquare:\n        this.attribute();\n        break;\n\n      case tokens.dollar:\n      case tokens.caret:\n      case tokens.equals:\n      case tokens.word:\n        this.word();\n        break;\n\n      case tokens.colon:\n        this.pseudo();\n        break;\n\n      case tokens.comma:\n        this.comma();\n        break;\n\n      case tokens.asterisk:\n        this.universal();\n        break;\n\n      case tokens.ampersand:\n        this.nesting();\n        break;\n\n      case tokens.slash:\n      case tokens.combinator:\n        this.combinator();\n        break;\n\n      case tokens.str:\n        this.string();\n        break;\n      // These cases throw; no break needed.\n\n      case tokens.closeSquare:\n        this.missingSquareBracket();\n\n      case tokens.semicolon:\n        this.missingBackslash();\n\n      default:\n        this.unexpected();\n    }\n  };\n  /**\n   * Helpers\n   */\n\n\n  Parser.prototype.expected = function expected(description, index, found) {\n    if (Array.isArray(description)) {\n      var last = description.pop();\n      description = description.join(', ') + ' or ' + last;\n    }\n\n    var an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';\n\n    if (!found) {\n      return this.error('Expected ' + an + ' ' + description + '.', {\n        index: index\n      });\n    }\n\n    return this.error('Expected ' + an + ' ' + description + ', found \"' + found + '\" instead.', {\n      index: index\n    });\n  };\n\n  Parser.prototype.requiredSpace = function requiredSpace(space) {\n    return this.options.lossy ? ' ' : space;\n  };\n\n  Parser.prototype.optionalSpace = function optionalSpace(space) {\n    return this.options.lossy ? '' : space;\n  };\n\n  Parser.prototype.lossySpace = function lossySpace(space, required) {\n    if (this.options.lossy) {\n      return required ? ' ' : '';\n    } else {\n      return space;\n    }\n  };\n\n  Parser.prototype.parseParenthesisToken = function parseParenthesisToken(token) {\n    var content = this.content(token);\n\n    if (token[_tokenize.FIELDS.TYPE] === tokens.space) {\n      return this.requiredSpace(content);\n    } else {\n      return content;\n    }\n  };\n\n  Parser.prototype.newNode = function newNode(node, namespace) {\n    if (namespace) {\n      if (/^ +$/.test(namespace)) {\n        if (!this.options.lossy) {\n          this.spaces = (this.spaces || '') + namespace;\n        }\n\n        namespace = true;\n      }\n\n      node.namespace = namespace;\n      unescapeProp(node, \"namespace\");\n    }\n\n    if (this.spaces) {\n      node.spaces.before = this.spaces;\n      this.spaces = '';\n    }\n\n    return this.current.append(node);\n  };\n\n  Parser.prototype.content = function content() {\n    var token = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.currToken;\n    return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);\n  };\n  /**\n   * returns the index of the next non-whitespace, non-comment token.\n   * returns -1 if no meaningful token is found.\n   */\n\n\n  Parser.prototype.locateNextMeaningfulToken = function locateNextMeaningfulToken() {\n    var startPosition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.position + 1;\n    var searchPosition = startPosition;\n\n    while (searchPosition < this.tokens.length) {\n      if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {\n        searchPosition++;\n        continue;\n      } else {\n        return searchPosition;\n      }\n    }\n\n    return -1;\n  };\n\n  _createClass(Parser, [{\n    key: 'currToken',\n    get: function get() {\n      return this.tokens[this.position];\n    }\n  }, {\n    key: 'nextToken',\n    get: function get() {\n      return this.tokens[this.position + 1];\n    }\n  }, {\n    key: 'prevToken',\n    get: function get() {\n      return this.tokens[this.position - 1];\n    }\n  }]);\n\n  return Parser;\n}();\n\nexports.default = Parser;\nmodule.exports = exports['default'];","map":{"version":3,"sources":["/Users/santando/xlbas-project/node_modules/postcss-selector-parser/dist/parser.js"],"names":["exports","__esModule","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","prototype","_extends","assign","arguments","source","hasOwnProperty","call","_WHITESPACE_TOKENS","_extends2","_indexesOf","require","_indexesOf2","_interopRequireDefault","_uniq","_uniq2","_root","_root2","_selector","_selector2","_className","_className2","_comment","_comment2","_id","_id2","_tag","_tag2","_string","_string2","_pseudo","_pseudo2","_attribute","_attribute2","_universal","_universal2","_combinator","_combinator2","_nesting","_nesting2","_sortAscending","_sortAscending2","_tokenize","_tokenize2","_tokenTypes","tokens","_interopRequireWildcard","_types","types","_util","obj","newObj","default","_classCallCheck","instance","TypeError","WHITESPACE_TOKENS","space","cr","feed","newline","tab","WHITESPACE_EQUIV_TOKENS","comment","tokenStart","token","line","FIELDS","START_LINE","column","START_COL","tokenEnd","END_LINE","END_COL","getSource","startLine","startColumn","endLine","endColumn","start","end","getTokenSource","getTokenSourceSpan","startToken","endToken","undefined","unescapeProp","node","prop","value","indexOf","ensureObject","unesc","raws","Parser","rule","options","lossy","safe","position","css","selector","error","_errorGenerator","rootSource","root","errorGenerator","append","current","loop","_this","message","errorOptions","Error","attribute","attr","startingToken","currToken","TYPE","closeSquare","push","expected","START_POS","len","sourceIndex","word","pos","spaceBefore","commentBefore","lastAdded","spaceAfterMeaningfulToken","content","next","prevContent","spaces","after","existingComment","getProp","asterisk","equals","operator","namespace","before","rawValue","dollar","oldRawValue","caret","combinator","_rawValue","_unescaped","_oldRawValue","oldValue","quoteMark","insensitive","insensitiveFlag","str","index","_unescapeValue","unescapeValue","unescaped","lastComment","rawLastComment","lastValue","rawLastValue","newNode","parseWhitespaceEquivalentTokens","stopPosition","startPosition","nodes","firstToken","lastToken","convertWhitespaceNodesToSpace","_this2","requiredSpace","rawSpace","forEach","n","lossySpace","rawSpaceBefore","rawSpaceAfter","result","isNamedCombinator","slash","namedCombinator","nameRaw","name","toLowerCase","unexpected","_this3","nextSigTokenPos","locateNextMeaningfulToken","comma","last","_convertWhitespaceNod","spaceOrDescendantSelectorNodes","_convertWhitespaceNod2","_space","_rawSpace","_convertWhitespaceNod3","_space2","_rawSpace2","endsWith","slice","startsWith","optionalSpace","trailingComma","_inferEndPosition","parent","opts","missingBackslash","missingParenthesis","missingSquareBracket","prevToken","nextToken","universal","nesting","nextContent","parentheses","unbalanced","type","PSEUDO","cache","openParenthesis","closeParenthesis","parse","parenStart","parenValue","parenEnd","parseParenthesisToken","appendToPropertyAndEscape","pseudo","_this4","pseudoStr","colon","splitWord","first","string","firstCallback","_this5","lastIndexOf","hasClass","filter","hasId","interpolations","hashIndex","indices","concat","ind","classNameOpts","idOpts","tagOpts","throwOnParenthesis","openSquare","ampersand","semicolon","description","found","Array","isArray","pop","join","an","test","required","END_POS","searchPosition","get","module"],"mappings":"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","sourcesContent":["'use strict';\n\nexports.__esModule = true;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _WHITESPACE_TOKENS, _extends2;\n\nvar _indexesOf = require('indexes-of');\n\nvar _indexesOf2 = _interopRequireDefault(_indexesOf);\n\nvar _uniq = require('uniq');\n\nvar _uniq2 = _interopRequireDefault(_uniq);\n\nvar _root = require('./selectors/root');\n\nvar _root2 = _interopRequireDefault(_root);\n\nvar _selector = require('./selectors/selector');\n\nvar _selector2 = _interopRequireDefault(_selector);\n\nvar _className = require('./selectors/className');\n\nvar _className2 = _interopRequireDefault(_className);\n\nvar _comment = require('./selectors/comment');\n\nvar _comment2 = _interopRequireDefault(_comment);\n\nvar _id = require('./selectors/id');\n\nvar _id2 = _interopRequireDefault(_id);\n\nvar _tag = require('./selectors/tag');\n\nvar _tag2 = _interopRequireDefault(_tag);\n\nvar _string = require('./selectors/string');\n\nvar _string2 = _interopRequireDefault(_string);\n\nvar _pseudo = require('./selectors/pseudo');\n\nvar _pseudo2 = _interopRequireDefault(_pseudo);\n\nvar _attribute = require('./selectors/attribute');\n\nvar _attribute2 = _interopRequireDefault(_attribute);\n\nvar _universal = require('./selectors/universal');\n\nvar _universal2 = _interopRequireDefault(_universal);\n\nvar _combinator = require('./selectors/combinator');\n\nvar _combinator2 = _interopRequireDefault(_combinator);\n\nvar _nesting = require('./selectors/nesting');\n\nvar _nesting2 = _interopRequireDefault(_nesting);\n\nvar _sortAscending = require('./sortAscending');\n\nvar _sortAscending2 = _interopRequireDefault(_sortAscending);\n\nvar _tokenize = require('./tokenize');\n\nvar _tokenize2 = _interopRequireDefault(_tokenize);\n\nvar _tokenTypes = require('./tokenTypes');\n\nvar tokens = _interopRequireWildcard(_tokenTypes);\n\nvar _types = require('./selectors/types');\n\nvar types = _interopRequireWildcard(_types);\n\nvar _util = require('./util');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);\n\nvar WHITESPACE_EQUIV_TOKENS = _extends({}, WHITESPACE_TOKENS, (_extends2 = {}, _extends2[tokens.comment] = true, _extends2));\n\nfunction tokenStart(token) {\n    return {\n        line: token[_tokenize.FIELDS.START_LINE],\n        column: token[_tokenize.FIELDS.START_COL]\n    };\n}\n\nfunction tokenEnd(token) {\n    return {\n        line: token[_tokenize.FIELDS.END_LINE],\n        column: token[_tokenize.FIELDS.END_COL]\n    };\n}\n\nfunction getSource(startLine, startColumn, endLine, endColumn) {\n    return {\n        start: {\n            line: startLine,\n            column: startColumn\n        },\n        end: {\n            line: endLine,\n            column: endColumn\n        }\n    };\n}\n\nfunction getTokenSource(token) {\n    return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);\n}\n\nfunction getTokenSourceSpan(startToken, endToken) {\n    if (!startToken) {\n        return undefined;\n    }\n    return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);\n}\n\nfunction unescapeProp(node, prop) {\n    var value = node[prop];\n    if (typeof value !== \"string\") {\n        return;\n    }\n    if (value.indexOf(\"\\\\\") !== -1) {\n        (0, _util.ensureObject)(node, 'raws');\n        node[prop] = (0, _util.unesc)(value);\n        if (node.raws[prop] === undefined) {\n            node.raws[prop] = value;\n        }\n    }\n    return node;\n}\n\nvar Parser = function () {\n    function Parser(rule) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        _classCallCheck(this, Parser);\n\n        this.rule = rule;\n        this.options = Object.assign({ lossy: false, safe: false }, options);\n        this.position = 0;\n\n        this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;\n\n        this.tokens = (0, _tokenize2.default)({\n            css: this.css,\n            error: this._errorGenerator(),\n            safe: this.options.safe\n        });\n\n        var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);\n        this.root = new _root2.default({ source: rootSource });\n        this.root.errorGenerator = this._errorGenerator();\n\n        var selector = new _selector2.default({ source: { start: { line: 1, column: 1 } } });\n        this.root.append(selector);\n        this.current = selector;\n\n        this.loop();\n    }\n\n    Parser.prototype._errorGenerator = function _errorGenerator() {\n        var _this = this;\n\n        return function (message, errorOptions) {\n            if (typeof _this.rule === 'string') {\n                return new Error(message);\n            }\n            return _this.rule.error(message, errorOptions);\n        };\n    };\n\n    Parser.prototype.attribute = function attribute() {\n        var attr = [];\n        var startingToken = this.currToken;\n        this.position++;\n        while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {\n            attr.push(this.currToken);\n            this.position++;\n        }\n        if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {\n            return this.expected('closing square bracket', this.currToken[_tokenize.FIELDS.START_POS]);\n        }\n\n        var len = attr.length;\n        var node = {\n            source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),\n            sourceIndex: startingToken[_tokenize.FIELDS.START_POS]\n        };\n\n        if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {\n            return this.expected('attribute', attr[0][_tokenize.FIELDS.START_POS]);\n        }\n\n        var pos = 0;\n        var spaceBefore = '';\n        var commentBefore = '';\n        var lastAdded = null;\n        var spaceAfterMeaningfulToken = false;\n\n        while (pos < len) {\n            var token = attr[pos];\n            var content = this.content(token);\n            var next = attr[pos + 1];\n\n            switch (token[_tokenize.FIELDS.TYPE]) {\n                case tokens.space:\n                    // if (\n                    //     len === 1 ||\n                    //     pos === 0 && this.content(next) === '|'\n                    // ) {\n                    //     return this.expected('attribute', token[TOKEN.START_POS], content);\n                    // }\n                    spaceAfterMeaningfulToken = true;\n                    if (this.options.lossy) {\n                        break;\n                    }\n                    if (lastAdded) {\n                        (0, _util.ensureObject)(node, 'spaces', lastAdded);\n                        var prevContent = node.spaces[lastAdded].after || '';\n                        node.spaces[lastAdded].after = prevContent + content;\n\n                        var existingComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || null;\n\n                        if (existingComment) {\n                            node.raws.spaces[lastAdded].after = existingComment + content;\n                        }\n                    } else {\n                        spaceBefore = spaceBefore + content;\n                        commentBefore = commentBefore + content;\n                    }\n                    break;\n                case tokens.asterisk:\n                    if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n                        node.operator = content;\n                        lastAdded = 'operator';\n                    } else if ((!node.namespace || lastAdded === \"namespace\" && !spaceAfterMeaningfulToken) && next) {\n                        if (spaceBefore) {\n                            (0, _util.ensureObject)(node, 'spaces', 'attribute');\n                            node.spaces.attribute.before = spaceBefore;\n                            spaceBefore = '';\n                        }\n                        if (commentBefore) {\n                            (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');\n                            node.raws.spaces.attribute.before = spaceBefore;\n                            commentBefore = '';\n                        }\n                        node.namespace = (node.namespace || \"\") + content;\n                        var rawValue = (0, _util.getProp)(node, 'raws', 'namespace') || null;\n                        if (rawValue) {\n                            node.raws.namespace += content;\n                        }\n                        lastAdded = 'namespace';\n                    }\n                    spaceAfterMeaningfulToken = false;\n                    break;\n                case tokens.dollar:\n                    if (lastAdded === \"value\") {\n                        var oldRawValue = (0, _util.getProp)(node, 'raws', 'value');\n                        node.value += \"$\";\n                        if (oldRawValue) {\n                            node.raws.value = oldRawValue + \"$\";\n                        }\n                        break;\n                    }\n                // Falls through\n                case tokens.caret:\n                    if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n                        node.operator = content;\n                        lastAdded = 'operator';\n                    }\n                    spaceAfterMeaningfulToken = false;\n                    break;\n                case tokens.combinator:\n                    if (content === '~' && next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n                        node.operator = content;\n                        lastAdded = 'operator';\n                    }\n                    if (content !== '|') {\n                        spaceAfterMeaningfulToken = false;\n                        break;\n                    }\n                    if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n                        node.operator = content;\n                        lastAdded = 'operator';\n                    } else if (!node.namespace && !node.attribute) {\n                        node.namespace = true;\n                    }\n                    spaceAfterMeaningfulToken = false;\n                    break;\n                case tokens.word:\n                    if (next && this.content(next) === '|' && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.\n                    !node.operator && !node.namespace) {\n                        node.namespace = content;\n                        lastAdded = 'namespace';\n                    } else if (!node.attribute || lastAdded === \"attribute\" && !spaceAfterMeaningfulToken) {\n                        if (spaceBefore) {\n                            (0, _util.ensureObject)(node, 'spaces', 'attribute');\n                            node.spaces.attribute.before = spaceBefore;\n\n                            spaceBefore = '';\n                        }\n                        if (commentBefore) {\n                            (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');\n                            node.raws.spaces.attribute.before = commentBefore;\n                            commentBefore = '';\n                        }\n                        node.attribute = (node.attribute || \"\") + content;\n                        var _rawValue = (0, _util.getProp)(node, 'raws', 'attribute') || null;\n                        if (_rawValue) {\n                            node.raws.attribute += content;\n                        }\n                        lastAdded = 'attribute';\n                    } else if (!node.value || lastAdded === \"value\" && !spaceAfterMeaningfulToken) {\n                        var _unescaped = (0, _util.unesc)(content);\n                        var _oldRawValue = (0, _util.getProp)(node, 'raws', 'value') || '';\n                        var oldValue = node.value || '';\n                        node.value = oldValue + _unescaped;\n                        node.quoteMark = null;\n                        if (_unescaped !== content || _oldRawValue) {\n                            (0, _util.ensureObject)(node, 'raws');\n                            node.raws.value = (_oldRawValue || oldValue) + content;\n                        }\n                        lastAdded = 'value';\n                    } else {\n                        var insensitive = content === 'i' || content === \"I\";\n                        if (node.value && (node.quoteMark || spaceAfterMeaningfulToken)) {\n                            node.insensitive = insensitive;\n                            if (!insensitive || content === \"I\") {\n                                (0, _util.ensureObject)(node, 'raws');\n                                node.raws.insensitiveFlag = content;\n                            }\n                            lastAdded = 'insensitive';\n                            if (spaceBefore) {\n                                (0, _util.ensureObject)(node, 'spaces', 'insensitive');\n                                node.spaces.insensitive.before = spaceBefore;\n\n                                spaceBefore = '';\n                            }\n                            if (commentBefore) {\n                                (0, _util.ensureObject)(node, 'raws', 'spaces', 'insensitive');\n                                node.raws.spaces.insensitive.before = commentBefore;\n                                commentBefore = '';\n                            }\n                        } else if (node.value) {\n                            lastAdded = 'value';\n                            node.value += content;\n                            if (node.raws.value) {\n                                node.raws.value += content;\n                            }\n                        }\n                    }\n                    spaceAfterMeaningfulToken = false;\n                    break;\n                case tokens.str:\n                    if (!node.attribute || !node.operator) {\n                        return this.error('Expected an attribute followed by an operator preceding the string.', {\n                            index: token[_tokenize.FIELDS.START_POS]\n                        });\n                    }\n\n                    var _unescapeValue = (0, _attribute.unescapeValue)(content),\n                        unescaped = _unescapeValue.unescaped,\n                        quoteMark = _unescapeValue.quoteMark;\n\n                    node.value = unescaped;\n                    node.quoteMark = quoteMark;\n                    lastAdded = 'value';\n\n                    (0, _util.ensureObject)(node, 'raws');\n                    node.raws.value = content;\n\n                    spaceAfterMeaningfulToken = false;\n                    break;\n                case tokens.equals:\n                    if (!node.attribute) {\n                        return this.expected('attribute', token[_tokenize.FIELDS.START_POS], content);\n                    }\n                    if (node.value) {\n                        return this.error('Unexpected \"=\" found; an operator was already defined.', { index: token[_tokenize.FIELDS.START_POS] });\n                    }\n                    node.operator = node.operator ? node.operator + content : content;\n                    lastAdded = 'operator';\n                    spaceAfterMeaningfulToken = false;\n                    break;\n                case tokens.comment:\n                    if (lastAdded) {\n                        if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === 'insensitive') {\n                            var lastComment = (0, _util.getProp)(node, 'spaces', lastAdded, 'after') || '';\n                            var rawLastComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || lastComment;\n\n                            (0, _util.ensureObject)(node, 'raws', 'spaces', lastAdded);\n                            node.raws.spaces[lastAdded].after = rawLastComment + content;\n                        } else {\n                            var lastValue = node[lastAdded] || '';\n                            var rawLastValue = (0, _util.getProp)(node, 'raws', lastAdded) || lastValue;\n                            (0, _util.ensureObject)(node, 'raws');\n                            node.raws[lastAdded] = rawLastValue + content;\n                        }\n                    } else {\n                        commentBefore = commentBefore + content;\n                    }\n                    break;\n                default:\n                    return this.error('Unexpected \"' + content + '\" found.', { index: token[_tokenize.FIELDS.START_POS] });\n            }\n            pos++;\n        }\n        unescapeProp(node, \"attribute\");\n        unescapeProp(node, \"namespace\");\n        this.newNode(new _attribute2.default(node));\n        this.position++;\n    };\n\n    /**\n     * return a node containing meaningless garbage up to (but not including) the specified token position.\n     * if the token position is negative, all remaining tokens are consumed.\n     *\n     * This returns an array containing a single string node if all whitespace,\n     * otherwise an array of comment nodes with space before and after.\n     *\n     * These tokens are not added to the current selector, the caller can add them or use them to amend\n     * a previous node's space metadata.\n     *\n     * In lossy mode, this returns only comments.\n     */\n\n\n    Parser.prototype.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {\n        if (stopPosition < 0) {\n            stopPosition = this.tokens.length;\n        }\n        var startPosition = this.position;\n        var nodes = [];\n        var space = \"\";\n        var lastComment = undefined;\n        do {\n            if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {\n                if (!this.options.lossy) {\n                    space += this.content();\n                }\n            } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {\n                var spaces = {};\n                if (space) {\n                    spaces.before = space;\n                    space = \"\";\n                }\n                lastComment = new _comment2.default({\n                    value: this.content(),\n                    source: getTokenSource(this.currToken),\n                    sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],\n                    spaces: spaces\n                });\n                nodes.push(lastComment);\n            }\n        } while (++this.position < stopPosition);\n\n        if (space) {\n            if (lastComment) {\n                lastComment.spaces.after = space;\n            } else if (!this.options.lossy) {\n                var firstToken = this.tokens[startPosition];\n                var lastToken = this.tokens[this.position - 1];\n                nodes.push(new _string2.default({\n                    value: '',\n                    source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),\n                    sourceIndex: firstToken[_tokenize.FIELDS.START_POS],\n                    spaces: { before: space, after: '' }\n                }));\n            }\n        }\n        return nodes;\n    };\n\n    /**\n     * \n     * @param {*} nodes \n     */\n\n\n    Parser.prototype.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes) {\n        var _this2 = this;\n\n        var requiredSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        var space = \"\";\n        var rawSpace = \"\";\n        nodes.forEach(function (n) {\n            var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);\n            var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);\n            space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);\n            rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);\n        });\n        if (rawSpace === space) {\n            rawSpace = undefined;\n        }\n        var result = { space: space, rawSpace: rawSpace };\n        return result;\n    };\n\n    Parser.prototype.isNamedCombinator = function isNamedCombinator() {\n        var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.position;\n\n        return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;\n    };\n\n    Parser.prototype.namedCombinator = function namedCombinator() {\n        if (this.isNamedCombinator()) {\n            var nameRaw = this.content(this.tokens[this.position + 1]);\n            var name = (0, _util.unesc)(nameRaw).toLowerCase();\n            var raws = {};\n            if (name !== nameRaw) {\n                raws.value = '/' + nameRaw + '/';\n            }\n            var node = new _combinator2.default({\n                value: '/' + name + '/',\n                source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),\n                sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],\n                raws: raws\n            });\n            this.position = this.position + 3;\n            return node;\n        } else {\n            this.unexpected();\n        }\n    };\n\n    Parser.prototype.combinator = function combinator() {\n        var _this3 = this;\n\n        if (this.content() === '|') {\n            return this.namespace();\n        }\n        // We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.\n        var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);\n\n        if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {\n            var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n            if (nodes.length > 0) {\n                var last = this.current.last;\n                if (last) {\n                    var _convertWhitespaceNod = this.convertWhitespaceNodesToSpace(nodes),\n                        space = _convertWhitespaceNod.space,\n                        rawSpace = _convertWhitespaceNod.rawSpace;\n\n                    if (rawSpace !== undefined) {\n                        last.rawSpaceAfter += rawSpace;\n                    }\n                    last.spaces.after += space;\n                } else {\n                    nodes.forEach(function (n) {\n                        return _this3.newNode(n);\n                    });\n                }\n            }\n            return;\n        }\n\n        var firstToken = this.currToken;\n        var spaceOrDescendantSelectorNodes = undefined;\n        if (nextSigTokenPos > this.position) {\n            spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n        }\n\n        var node = void 0;\n        if (this.isNamedCombinator()) {\n            node = this.namedCombinator();\n        } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {\n            node = new _combinator2.default({\n                value: this.content(),\n                source: getTokenSource(this.currToken),\n                sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]\n            });\n            this.position++;\n        } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {\n            // pass\n        } else if (!spaceOrDescendantSelectorNodes) {\n            this.unexpected();\n        }\n\n        if (node) {\n            if (spaceOrDescendantSelectorNodes) {\n                var _convertWhitespaceNod2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes),\n                    _space = _convertWhitespaceNod2.space,\n                    _rawSpace = _convertWhitespaceNod2.rawSpace;\n\n                node.spaces.before = _space;\n                node.rawSpaceBefore = _rawSpace;\n            }\n        } else {\n            // descendant combinator\n            var _convertWhitespaceNod3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true),\n                _space2 = _convertWhitespaceNod3.space,\n                _rawSpace2 = _convertWhitespaceNod3.rawSpace;\n\n            if (!_rawSpace2) {\n                _rawSpace2 = _space2;\n            }\n            var spaces = {};\n            var raws = { spaces: {} };\n            if (_space2.endsWith(' ') && _rawSpace2.endsWith(' ')) {\n                spaces.before = _space2.slice(0, _space2.length - 1);\n                raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);\n            } else if (_space2.startsWith(' ') && _rawSpace2.startsWith(' ')) {\n                spaces.after = _space2.slice(1);\n                raws.spaces.after = _rawSpace2.slice(1);\n            } else {\n                raws.value = _rawSpace2;\n            }\n            node = new _combinator2.default({\n                value: ' ',\n                source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),\n                sourceIndex: firstToken[_tokenize.FIELDS.START_POS],\n                spaces: spaces,\n                raws: raws\n            });\n        }\n\n        if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {\n            node.spaces.after = this.optionalSpace(this.content());\n            this.position++;\n        }\n\n        return this.newNode(node);\n    };\n\n    Parser.prototype.comma = function comma() {\n        if (this.position === this.tokens.length - 1) {\n            this.root.trailingComma = true;\n            this.position++;\n            return;\n        }\n        this.current._inferEndPosition();\n        var selector = new _selector2.default({ source: { start: tokenStart(this.tokens[this.position + 1]) } });\n        this.current.parent.append(selector);\n        this.current = selector;\n        this.position++;\n    };\n\n    Parser.prototype.comment = function comment() {\n        var current = this.currToken;\n        this.newNode(new _comment2.default({\n            value: this.content(),\n            source: getTokenSource(current),\n            sourceIndex: current[_tokenize.FIELDS.START_POS]\n        }));\n        this.position++;\n    };\n\n    Parser.prototype.error = function error(message, opts) {\n        throw this.root.error(message, opts);\n    };\n\n    Parser.prototype.missingBackslash = function missingBackslash() {\n        return this.error('Expected a backslash preceding the semicolon.', {\n            index: this.currToken[_tokenize.FIELDS.START_POS]\n        });\n    };\n\n    Parser.prototype.missingParenthesis = function missingParenthesis() {\n        return this.expected('opening parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);\n    };\n\n    Parser.prototype.missingSquareBracket = function missingSquareBracket() {\n        return this.expected('opening square bracket', this.currToken[_tokenize.FIELDS.START_POS]);\n    };\n\n    Parser.prototype.unexpected = function unexpected() {\n        return this.error('Unexpected \\'' + this.content() + '\\'. Escaping special characters with \\\\ may help.', this.currToken[_tokenize.FIELDS.START_POS]);\n    };\n\n    Parser.prototype.namespace = function namespace() {\n        var before = this.prevToken && this.content(this.prevToken) || true;\n        if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {\n            this.position++;\n            return this.word(before);\n        } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {\n            this.position++;\n            return this.universal(before);\n        }\n    };\n\n    Parser.prototype.nesting = function nesting() {\n        if (this.nextToken) {\n            var nextContent = this.content(this.nextToken);\n            if (nextContent === \"|\") {\n                this.position++;\n                return;\n            }\n        }\n        var current = this.currToken;\n        this.newNode(new _nesting2.default({\n            value: this.content(),\n            source: getTokenSource(current),\n            sourceIndex: current[_tokenize.FIELDS.START_POS]\n        }));\n        this.position++;\n    };\n\n    Parser.prototype.parentheses = function parentheses() {\n        var last = this.current.last;\n        var unbalanced = 1;\n        this.position++;\n        if (last && last.type === types.PSEUDO) {\n            var selector = new _selector2.default({ source: { start: tokenStart(this.tokens[this.position - 1]) } });\n            var cache = this.current;\n            last.append(selector);\n            this.current = selector;\n            while (this.position < this.tokens.length && unbalanced) {\n                if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n                    unbalanced++;\n                }\n                if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n                    unbalanced--;\n                }\n                if (unbalanced) {\n                    this.parse();\n                } else {\n                    this.current.source.end = tokenEnd(this.currToken);\n                    this.current.parent.source.end = tokenEnd(this.currToken);\n                    this.position++;\n                }\n            }\n            this.current = cache;\n        } else {\n            // I think this case should be an error. It's used to implement a basic parse of media queries\n            // but I don't think it's a good idea.\n            var parenStart = this.currToken;\n            var parenValue = \"(\";\n            var parenEnd = void 0;\n            while (this.position < this.tokens.length && unbalanced) {\n                if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n                    unbalanced++;\n                }\n                if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n                    unbalanced--;\n                }\n                parenEnd = this.currToken;\n                parenValue += this.parseParenthesisToken(this.currToken);\n                this.position++;\n            }\n            if (last) {\n                last.appendToPropertyAndEscape(\"value\", parenValue, parenValue);\n            } else {\n                this.newNode(new _string2.default({\n                    value: parenValue,\n                    source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),\n                    sourceIndex: parenStart[_tokenize.FIELDS.START_POS]\n                }));\n            }\n        }\n        if (unbalanced) {\n            return this.expected('closing parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);\n        }\n    };\n\n    Parser.prototype.pseudo = function pseudo() {\n        var _this4 = this;\n\n        var pseudoStr = '';\n        var startingToken = this.currToken;\n        while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {\n            pseudoStr += this.content();\n            this.position++;\n        }\n        if (!this.currToken) {\n            return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);\n        }\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {\n            this.splitWord(false, function (first, length) {\n                pseudoStr += first;\n                _this4.newNode(new _pseudo2.default({\n                    value: pseudoStr,\n                    source: getTokenSourceSpan(startingToken, _this4.currToken),\n                    sourceIndex: startingToken[_tokenize.FIELDS.START_POS]\n                }));\n                if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n                    _this4.error('Misplaced parenthesis.', {\n                        index: _this4.nextToken[_tokenize.FIELDS.START_POS]\n                    });\n                }\n            });\n        } else {\n            return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[_tokenize.FIELDS.START_POS]);\n        }\n    };\n\n    Parser.prototype.space = function space() {\n        var content = this.content();\n        // Handle space before and after the selector\n        if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n            this.spaces = this.optionalSpace(content);\n            this.position++;\n        } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n            this.current.last.spaces.after = this.optionalSpace(content);\n            this.position++;\n        } else {\n            this.combinator();\n        }\n    };\n\n    Parser.prototype.string = function string() {\n        var current = this.currToken;\n        this.newNode(new _string2.default({\n            value: this.content(),\n            source: getTokenSource(current),\n            sourceIndex: current[_tokenize.FIELDS.START_POS]\n        }));\n        this.position++;\n    };\n\n    Parser.prototype.universal = function universal(namespace) {\n        var nextToken = this.nextToken;\n        if (nextToken && this.content(nextToken) === '|') {\n            this.position++;\n            return this.namespace();\n        }\n        var current = this.currToken;\n        this.newNode(new _universal2.default({\n            value: this.content(),\n            source: getTokenSource(current),\n            sourceIndex: current[_tokenize.FIELDS.START_POS]\n        }), namespace);\n        this.position++;\n    };\n\n    Parser.prototype.splitWord = function splitWord(namespace, firstCallback) {\n        var _this5 = this;\n\n        var nextToken = this.nextToken;\n        var word = this.content();\n        while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {\n            this.position++;\n            var current = this.content();\n            word += current;\n            if (current.lastIndexOf('\\\\') === current.length - 1) {\n                var next = this.nextToken;\n                if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {\n                    word += this.requiredSpace(this.content(next));\n                    this.position++;\n                }\n            }\n            nextToken = this.nextToken;\n        }\n        var hasClass = (0, _indexesOf2.default)(word, '.').filter(function (i) {\n            return word[i - 1] !== '\\\\';\n        });\n        var hasId = (0, _indexesOf2.default)(word, '#');\n        // Eliminate Sass interpolations from the list of id indexes\n        var interpolations = (0, _indexesOf2.default)(word, '#{');\n        if (interpolations.length) {\n            hasId = hasId.filter(function (hashIndex) {\n                return !~interpolations.indexOf(hashIndex);\n            });\n        }\n        var indices = (0, _sortAscending2.default)((0, _uniq2.default)([0].concat(hasClass, hasId)));\n        indices.forEach(function (ind, i) {\n            var index = indices[i + 1] || word.length;\n            var value = word.slice(ind, index);\n            if (i === 0 && firstCallback) {\n                return firstCallback.call(_this5, value, indices.length);\n            }\n            var node = void 0;\n            var current = _this5.currToken;\n            var sourceIndex = current[_tokenize.FIELDS.START_POS] + indices[i];\n            var source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));\n            if (~hasClass.indexOf(ind)) {\n                var classNameOpts = {\n                    value: value.slice(1),\n                    source: source,\n                    sourceIndex: sourceIndex\n                };\n                node = new _className2.default(unescapeProp(classNameOpts, \"value\"));\n            } else if (~hasId.indexOf(ind)) {\n                var idOpts = {\n                    value: value.slice(1),\n                    source: source,\n                    sourceIndex: sourceIndex\n                };\n                node = new _id2.default(unescapeProp(idOpts, \"value\"));\n            } else {\n                var tagOpts = {\n                    value: value,\n                    source: source,\n                    sourceIndex: sourceIndex\n                };\n                unescapeProp(tagOpts, \"value\");\n                node = new _tag2.default(tagOpts);\n            }\n            _this5.newNode(node, namespace);\n            // Ensure that the namespace is used only once\n            namespace = null;\n        });\n        this.position++;\n    };\n\n    Parser.prototype.word = function word(namespace) {\n        var nextToken = this.nextToken;\n        if (nextToken && this.content(nextToken) === '|') {\n            this.position++;\n            return this.namespace();\n        }\n        return this.splitWord(namespace);\n    };\n\n    Parser.prototype.loop = function loop() {\n        while (this.position < this.tokens.length) {\n            this.parse(true);\n        }\n        this.current._inferEndPosition();\n        return this.root;\n    };\n\n    Parser.prototype.parse = function parse(throwOnParenthesis) {\n        switch (this.currToken[_tokenize.FIELDS.TYPE]) {\n            case tokens.space:\n                this.space();\n                break;\n            case tokens.comment:\n                this.comment();\n                break;\n            case tokens.openParenthesis:\n                this.parentheses();\n                break;\n            case tokens.closeParenthesis:\n                if (throwOnParenthesis) {\n                    this.missingParenthesis();\n                }\n                break;\n            case tokens.openSquare:\n                this.attribute();\n                break;\n            case tokens.dollar:\n            case tokens.caret:\n            case tokens.equals:\n            case tokens.word:\n                this.word();\n                break;\n            case tokens.colon:\n                this.pseudo();\n                break;\n            case tokens.comma:\n                this.comma();\n                break;\n            case tokens.asterisk:\n                this.universal();\n                break;\n            case tokens.ampersand:\n                this.nesting();\n                break;\n            case tokens.slash:\n            case tokens.combinator:\n                this.combinator();\n                break;\n            case tokens.str:\n                this.string();\n                break;\n            // These cases throw; no break needed.\n            case tokens.closeSquare:\n                this.missingSquareBracket();\n            case tokens.semicolon:\n                this.missingBackslash();\n            default:\n                this.unexpected();\n        }\n    };\n\n    /**\n     * Helpers\n     */\n\n    Parser.prototype.expected = function expected(description, index, found) {\n        if (Array.isArray(description)) {\n            var last = description.pop();\n            description = description.join(', ') + ' or ' + last;\n        }\n        var an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';\n        if (!found) {\n            return this.error('Expected ' + an + ' ' + description + '.', { index: index });\n        }\n        return this.error('Expected ' + an + ' ' + description + ', found \"' + found + '\" instead.', { index: index });\n    };\n\n    Parser.prototype.requiredSpace = function requiredSpace(space) {\n        return this.options.lossy ? ' ' : space;\n    };\n\n    Parser.prototype.optionalSpace = function optionalSpace(space) {\n        return this.options.lossy ? '' : space;\n    };\n\n    Parser.prototype.lossySpace = function lossySpace(space, required) {\n        if (this.options.lossy) {\n            return required ? ' ' : '';\n        } else {\n            return space;\n        }\n    };\n\n    Parser.prototype.parseParenthesisToken = function parseParenthesisToken(token) {\n        var content = this.content(token);\n        if (token[_tokenize.FIELDS.TYPE] === tokens.space) {\n            return this.requiredSpace(content);\n        } else {\n            return content;\n        }\n    };\n\n    Parser.prototype.newNode = function newNode(node, namespace) {\n        if (namespace) {\n            if (/^ +$/.test(namespace)) {\n                if (!this.options.lossy) {\n                    this.spaces = (this.spaces || '') + namespace;\n                }\n                namespace = true;\n            }\n            node.namespace = namespace;\n            unescapeProp(node, \"namespace\");\n        }\n        if (this.spaces) {\n            node.spaces.before = this.spaces;\n            this.spaces = '';\n        }\n        return this.current.append(node);\n    };\n\n    Parser.prototype.content = function content() {\n        var token = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.currToken;\n\n        return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);\n    };\n\n    /**\n     * returns the index of the next non-whitespace, non-comment token.\n     * returns -1 if no meaningful token is found.\n     */\n    Parser.prototype.locateNextMeaningfulToken = function locateNextMeaningfulToken() {\n        var startPosition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.position + 1;\n\n        var searchPosition = startPosition;\n        while (searchPosition < this.tokens.length) {\n            if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {\n                searchPosition++;\n                continue;\n            } else {\n                return searchPosition;\n            }\n        }\n        return -1;\n    };\n\n    _createClass(Parser, [{\n        key: 'currToken',\n        get: function get() {\n            return this.tokens[this.position];\n        }\n    }, {\n        key: 'nextToken',\n        get: function get() {\n            return this.tokens[this.position + 1];\n        }\n    }, {\n        key: 'prevToken',\n        get: function get() {\n            return this.tokens[this.position - 1];\n        }\n    }]);\n\n    return Parser;\n}();\n\nexports.default = Parser;\nmodule.exports = exports['default'];"]},"metadata":{},"sourceType":"script"}